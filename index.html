<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Living Piece — Adaptive Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://unpkg.com/tone@14.9.17/build/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap");

      /* Navigation Header */
      .nav-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        display: flex;
        justify-content: center;
        padding: 12px 16px;
        background: rgba(10, 10, 10, 0.85);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      }

      .nav-tabs {
        display: flex;
        gap: 4px;
        padding: 4px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      .nav-tab {
        padding: 8px 20px;
        border: none;
        background: transparent;
        color: #606060;
        font-size: 13px;
        font-weight: 500;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-family: inherit;
        text-decoration: none;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .nav-tab:hover {
        color: #a0a0a0;
        background: rgba(255, 255, 255, 0.03);
      }

      .nav-tab.active {
        background: #0ea5e9;
        color: white;
        box-shadow: 0 2px 8px rgba(14, 165, 233, 0.3);
      }

      .nav-tab svg {
        width: 16px;
        height: 16px;
      }

      /* Track Selector Drawer */
      .track-drawer {
        position: fixed;
        left: 0;
        top: 56px;
        bottom: 0;
        width: 280px;
        background: rgba(14, 14, 14, 0.95);
        backdrop-filter: blur(20px);
        -webkit-backdrop-filter: blur(20px);
        border-right: 1px solid var(--border);
        z-index: 90;
        transform: translateX(-100%);
        transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        display: flex;
        flex-direction: column;
      }

      .track-drawer.open {
        transform: translateX(0);
      }

      .track-drawer-header {
        padding: 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .track-drawer-title {
        font-size: 12px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--muted);
      }

      .track-drawer-close {
        width: 28px;
        height: 28px;
        border: none;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        border-radius: 6px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .track-drawer-close:hover {
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
      }

      .track-drawer-close svg {
        width: 18px;
        height: 18px;
      }

      .track-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }

      .track-list-item {
        padding: 12px 14px;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.2s ease;
        margin-bottom: 4px;
        border: 1px solid transparent;
      }

      .track-list-item:hover {
        background: rgba(255, 255, 255, 0.03);
        border-color: var(--border);
      }

      .track-list-item.active {
        background: rgba(14, 165, 233, 0.1);
        border-color: rgba(14, 165, 233, 0.3);
      }

      .track-list-item.active .track-list-title {
        color: var(--accent-bright);
      }

      .track-list-title {
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .track-list-meta {
        font-size: 11px;
        color: var(--muted);
        display: flex;
        gap: 8px;
      }

      .track-list-empty {
        text-align: center;
        padding: 40px 20px;
        color: var(--muted);
        font-size: 13px;
      }

      .track-list-loading {
        text-align: center;
        padding: 40px 20px;
        color: var(--muted);
        font-size: 13px;
      }

      /* Track Toggle Button */
      .track-toggle {
        position: fixed;
        left: 16px;
        top: 72px;
        z-index: 85;
        width: 40px;
        height: 40px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(18, 18, 18, 0.9);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        color: var(--text-soft);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      }

      .track-toggle:hover {
        background: rgba(28, 28, 28, 0.95);
        border-color: var(--border-hover);
        color: var(--text);
      }

      .track-toggle.active {
        background: rgba(14, 165, 233, 0.15);
        border-color: rgba(14, 165, 233, 0.4);
        color: var(--accent-bright);
      }

      .track-toggle svg {
        width: 20px;
        height: 20px;
      }

      /* Drawer backdrop */
      .drawer-backdrop {
        position: fixed;
        inset: 0;
        background: rgba(0, 0, 0, 0.5);
        z-index: 80;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .drawer-backdrop.visible {
        opacity: 1;
        pointer-events: auto;
      }

      :root {
        /* Charcoal Base with Sky Blue Accents */
        --bg-deep: #0a0a0a;
        --bg-forest: #111111;
        --bg-panel: rgba(18, 18, 18, 0.75);
        --bg-card: rgba(28, 28, 28, 0.5);

        --border: rgba(255, 255, 255, 0.06);
        --border-hover: rgba(255, 255, 255, 0.12);
        --border-glow: rgba(56, 189, 248, 0.3);

        --text: #e8e8e8;
        --text-soft: #a0a0a0;
        --muted: #606060;

        --accent: #0ea5e9;
        --accent-bright: #38bdf8;
        --accent-glow: rgba(56, 189, 248, 0.25);
        --accent-deep: #0369a1;

        --warm: #c4956a;
        --warm-glow: rgba(196, 149, 106, 0.15);

        --radius: 20px;
        --radius-sm: 12px;
        --blur: 24px;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      html,
      body {
        height: 100%;
      }

      body {
        font-family: "Inter", system-ui, -apple-system, sans-serif;
        background: var(--bg-deep);
        color: var(--text);
        min-height: 100vh;
        overflow-x: hidden;
      }

      /* Subtle charcoal background */
      .bg-layer {
        position: fixed;
        inset: 0;
        z-index: 0;
        background: radial-gradient(
            ellipse 80% 50% at 20% 80%,
            rgba(30, 30, 30, 0.4) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse 60% 40% at 80% 20%,
            rgba(40, 40, 40, 0.2) 0%,
            transparent 50%
          ),
          radial-gradient(
            ellipse 100% 80% at 50% 100%,
            rgba(15, 15, 15, 0.9) 0%,
            transparent 60%
          ),
          linear-gradient(180deg, var(--bg-deep) 0%, var(--bg-forest) 100%);
      }

      /* Subtle floating particles */
      .particles {
        position: fixed;
        inset: 0;
        z-index: 1;
        pointer-events: none;
        opacity: 0.4;
      }

      .particle {
        position: absolute;
        width: 2px;
        height: 2px;
        background: rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        animation: float 20s infinite ease-in-out;
      }

      .particle:nth-child(3n) {
        background: var(--accent);
        box-shadow: 0 0 6px var(--accent-glow);
      }

      @keyframes float {
        0%,
        100% {
          transform: translateY(0) translateX(0);
          opacity: 0;
        }
        10% {
          opacity: 0.6;
        }
        50% {
          transform: translateY(-100px) translateX(20px);
          opacity: 0.3;
        }
        90% {
          opacity: 0.6;
        }
      }

      .app {
        position: relative;
        z-index: 10;
        min-height: 100vh;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 24px;
        padding-top: 80px; /* Account for fixed nav header */
      }

      .player-container {
        width: 100%;
        max-width: 480px;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      /* Glass Panel Base */
      .panel {
        padding: 24px;
        border-radius: var(--radius);
        backdrop-filter: blur(var(--blur));
        -webkit-backdrop-filter: blur(var(--blur));
        background: var(--bg-panel);
        border: 1px solid var(--border);
        box-shadow: 0 4px 24px rgba(0, 0, 0, 0.4),
          0 0 0 1px rgba(255, 255, 255, 0.02) inset,
          0 1px 0 rgba(255, 255, 255, 0.03) inset;
      }

      /* Album Art Section */
      .album-section {
        text-align: center;
      }

      .album-art {
        width: 100%;
        aspect-ratio: 1;
        border-radius: 16px;
        overflow: hidden;
        position: relative;
        background: #0a0a0a;
        box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6),
          0 0 60px rgba(236, 72, 153, 0.1), 0 0 80px rgba(56, 189, 248, 0.1);
        margin-bottom: 20px;
      }

      .album-art svg {
        width: 100%;
        height: 100%;
      }

      .album-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .album-art.playing img {
        animation: cover-pulse 3s ease-in-out infinite;
      }

      @keyframes cover-pulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.1);
        }
      }

      /* Geometric Album Art Animation */
      .geo-layer {
        transition: transform 8s ease-in-out;
      }

      .album-art:hover .geo-layer:nth-child(1) {
        transform: rotate(5deg);
      }
      .album-art:hover .geo-layer:nth-child(2) {
        transform: rotate(-3deg) scale(1.02);
      }

      .album-art.playing .pulse-ring {
        animation: pulse-glow 2s ease-in-out infinite;
      }

      @keyframes pulse-glow {
        0%,
        100% {
          opacity: 0.3;
          transform: scale(1);
        }
        50% {
          opacity: 0.6;
          transform: scale(1.02);
        }
      }

      .track-info {
        margin-bottom: 16px;
      }

      .track-title {
        font-size: 22px;
        font-weight: 600;
        letter-spacing: -0.02em;
        margin-bottom: 4px;
      }

      .track-artist {
        font-size: 14px;
        color: var(--text-soft);
        font-weight: 400;
      }

      /* Context Chips */
      .context-row {
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: wrap;
        margin-bottom: 20px;
      }

      .chip {
        padding: 6px 14px;
        border-radius: 999px;
        font-size: 12px;
        font-weight: 500;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid var(--border);
        color: var(--muted);
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .chip-icon {
        width: 14px;
        height: 14px;
        opacity: 0.5;
      }

      .chip.accent {
        background: rgba(56, 189, 248, 0.08);
        border-color: rgba(56, 189, 248, 0.3);
        color: var(--accent-bright);
        box-shadow: 0 0 12px var(--accent-glow);
      }

      /* Progress Bar */
      .progress-container {
        margin-bottom: 16px;
      }

      .progress-bar {
        width: 100%;
        height: 4px;
        background: rgba(255, 255, 255, 0.04);
        border-radius: 2px;
        overflow: hidden;
        cursor: pointer;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(
          90deg,
          var(--accent) 0%,
          var(--accent-bright) 100%
        );
        width: 0%;
        border-radius: 2px;
        transition: width 0.1s linear;
        box-shadow: 0 0 10px var(--accent-glow);
      }

      .time-display {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: var(--muted);
        margin-top: 8px;
        font-variant-numeric: tabular-nums;
      }

      /* Transport Controls */
      .transport {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 16px;
        margin-bottom: 20px;
      }

      .btn {
        border: none;
        background: transparent;
        color: var(--text-soft);
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .btn:hover {
        color: var(--text);
        transform: scale(1.1);
      }

      .btn-secondary {
        width: 44px;
        height: 44px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.02);
        border: 1px solid var(--border);
      }

      .btn-secondary:hover {
        background: rgba(255, 255, 255, 0.05);
        border-color: var(--border-hover);
      }

      .btn-play {
        width: 64px;
        height: 64px;
        border-radius: 50%;
        background: linear-gradient(
          135deg,
          var(--accent) 0%,
          var(--accent-deep) 100%
        );
        border: none;
        color: white;
        box-shadow: 0 4px 20px var(--accent-glow),
          0 0 0 1px rgba(255, 255, 255, 0.1) inset;
      }

      .btn-play:hover {
        background: linear-gradient(
          135deg,
          var(--accent-bright) 0%,
          var(--accent) 100%
        );
        box-shadow: 0 4px 30px var(--accent-glow),
          0 0 0 1px rgba(255, 255, 255, 0.15) inset;
        transform: scale(1.05);
      }

      .btn-play.playing {
        animation: play-pulse 2s ease-in-out infinite;
      }

      @keyframes play-pulse {
        0%,
        100% {
          box-shadow: 0 4px 20px var(--accent-glow);
        }
        50% {
          box-shadow: 0 4px 35px var(--accent-glow), 0 0 20px var(--accent-glow);
        }
      }

      .btn svg {
        width: 20px;
        height: 20px;
      }

      .btn-play svg {
        width: 26px;
        height: 26px;
        margin-left: 2px;
      }

      /* Mode Selector */
      .mode-selector {
        display: flex;
        gap: 8px;
        padding: 4px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: var(--radius-sm);
        margin-bottom: 16px;
      }

      .mode-btn {
        flex: 1;
        padding: 10px 12px;
        border: none;
        background: transparent;
        color: var(--muted);
        font-size: 12px;
        font-weight: 500;
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .mode-btn:hover {
        color: var(--text-soft);
        background: rgba(255, 255, 255, 0.02);
      }

      .mode-btn.active {
        background: rgba(56, 189, 248, 0.1);
        color: var(--accent-bright);
        box-shadow: 0 0 12px var(--accent-glow);
      }

      .instrumental-btn {
        width: 38px;
        height: 38px;
        padding: 0;
        border: none;
        background: transparent;
        color: var(--muted);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .instrumental-btn svg {
        width: 16px;
        height: 16px;
      }

      .instrumental-btn:hover {
        color: var(--text-soft);
        background: rgba(255, 255, 255, 0.05);
      }

      .instrumental-btn.active {
        background: rgba(236, 72, 153, 0.15);
        color: #ec4899;
      }

      .instrumental-btn.active svg {
        opacity: 0.5;
      }

      .calm-btn {
        width: 38px;
        height: 38px;
        padding: 0;
        border: none;
        background: transparent;
        color: var(--muted);
        border-radius: 8px;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
      }

      .calm-btn svg {
        width: 16px;
        height: 16px;
      }

      .calm-btn:hover {
        color: var(--text-soft);
        background: rgba(255, 255, 255, 0.05);
      }

      .calm-btn.active {
        background: rgba(147, 197, 253, 0.15);
        color: #93c5fd;
      }

      .calm-btn.active svg {
        opacity: 0.7;
      }

      /* Override Selectors */
      .controls-row {
        display: flex;
        gap: 12px;
      }

      .control-group {
        flex: 1;
      }

      .control-label {
        font-size: 11px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 6px;
      }

      .select-wrap {
        position: relative;
      }

      .select-wrap select {
        width: 100%;
        padding: 10px 32px 10px 12px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.3);
        color: var(--text-soft);
        font-size: 13px;
        font-family: inherit;
        appearance: none;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .select-wrap select:hover {
        border-color: var(--border-hover);
        background: rgba(0, 0, 0, 0.4);
      }

      .select-wrap select:focus {
        outline: none;
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .select-wrap::after {
        content: "";
        position: absolute;
        right: 12px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-left: 5px solid transparent;
        border-right: 5px solid transparent;
        border-top: 5px solid var(--muted);
        pointer-events: none;
      }

      /* Stems Panel */
      .stems-panel {
        padding: 20px;
      }

      .stems-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 12px;
      }

      .stems-title {
        font-size: 13px;
        font-weight: 500;
        color: var(--muted);
      }

      .regenerate-btn {
        padding: 6px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--muted);
        font-size: 12px;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .regenerate-btn:hover {
        border-color: rgba(56, 189, 248, 0.4);
        color: var(--accent-bright);
        background: rgba(56, 189, 248, 0.06);
      }

      .regenerate-btn svg {
        width: 14px;
        height: 14px;
      }

      .stems-grid {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 8px;
      }

      .stem-card {
        padding: 12px;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.015);
        border: 1px solid var(--border);
        transition: all 0.2s ease;
      }

      .stem-card:hover {
        background: rgba(255, 255, 255, 0.03);
        border-color: var(--border-hover);
      }

      .stem-card.surprise {
        border-color: rgba(196, 149, 106, 0.3);
        background: rgba(196, 149, 106, 0.05);
      }

      .stem-card.surprise .stem-role {
        color: var(--warm);
      }

      .stem-role {
        font-size: 12px;
        font-weight: 500;
        color: var(--accent-bright);
        margin-bottom: 2px;
      }

      .stem-take {
        font-size: 11px;
        color: var(--muted);
      }

      /* Save Dialog */
      .save-dialog {
        padding: 12px;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 10px;
        margin-bottom: 12px;
      }

      .mix-name-input {
        width: 100%;
        padding: 10px 12px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: rgba(0, 0, 0, 0.3);
        color: var(--text);
        font-size: 14px;
        font-family: inherit;
        margin-bottom: 10px;
        outline: none;
        transition: all 0.2s ease;
      }

      .mix-name-input:focus {
        border-color: var(--accent);
        box-shadow: 0 0 0 3px var(--accent-glow);
      }

      .mix-name-input::placeholder {
        color: var(--muted);
      }

      .save-dialog-buttons {
        display: flex;
        gap: 8px;
        justify-content: flex-end;
      }

      .dialog-btn {
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 13px;
        font-family: inherit;
        cursor: pointer;
        transition: all 0.2s ease;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text-soft);
      }

      .dialog-btn:hover {
        background: rgba(255, 255, 255, 0.05);
      }

      .dialog-btn.confirm {
        background: rgba(56, 189, 248, 0.15);
        border-color: var(--accent);
        color: var(--accent-bright);
      }

      .dialog-btn.confirm:hover {
        background: rgba(56, 189, 248, 0.25);
      }

      /* Saved Mixes List */
      .saved-mixes-list {
        display: flex;
        flex-direction: column;
        gap: 8px;
        max-height: 300px;
        overflow-y: auto;
      }

      .empty-state {
        text-align: center;
        color: var(--muted);
        font-size: 13px;
        padding: 20px;
      }

      .saved-mix-item {
        display: flex;
        align-items: center;
        gap: 12px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.015);
        border: 1px solid var(--border);
        border-radius: 10px;
        transition: all 0.2s ease;
      }

      .saved-mix-item:hover {
        background: rgba(255, 255, 255, 0.03);
        border-color: var(--border-hover);
      }

      .saved-mix-info {
        flex: 1;
        min-width: 0;
      }

      .saved-mix-name {
        font-size: 14px;
        font-weight: 500;
        color: var(--text);
        margin-bottom: 2px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .saved-mix-meta {
        font-size: 11px;
        color: var(--muted);
      }

      .saved-mix-actions {
        display: flex;
        gap: 6px;
      }

      .mix-action-btn {
        width: 32px;
        height: 32px;
        border-radius: 8px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .mix-action-btn:hover {
        background: rgba(255, 255, 255, 0.05);
        color: var(--text);
        border-color: var(--border-hover);
      }

      .mix-action-btn.play:hover {
        border-color: var(--accent);
        color: var(--accent-bright);
        background: rgba(56, 189, 248, 0.1);
      }

      .mix-action-btn.delete:hover {
        border-color: #ef4444;
        color: #f87171;
        background: rgba(239, 68, 68, 0.1);
      }

      .mix-action-btn svg {
        width: 16px;
        height: 16px;
      }

      /* Loading State */
      .loading-overlay {
        position: absolute;
        inset: 0;
        background: rgba(5, 10, 6, 0.9);
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 16px;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
      }

      .loading-overlay.active {
        opacity: 1;
        pointer-events: auto;
      }

      .loader {
        width: 40px;
        height: 40px;
        border: 2px solid var(--border);
        border-top-color: var(--accent);
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      /* Status Message */
      .status {
        text-align: center;
        font-size: 12px;
        color: var(--muted);
        min-height: 18px;
      }

      .status.error {
        color: #e57373;
      }

      .status.success {
        color: var(--accent-bright);
      }

      /* Responsive */
      @media (max-width: 520px) {
        .app {
          padding: 16px;
        }

        .panel {
          padding: 20px;
        }

        .transport {
          gap: 12px;
        }

        .btn-play {
          width: 56px;
          height: 56px;
        }

        .stems-grid {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>

  <body>
    <!-- Navigation Header -->
    <nav class="nav-header">
      <div class="nav-tabs">
        <a href="#" class="nav-tab active">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M9 18V5l12-2v13" />
            <circle cx="6" cy="18" r="3" />
            <circle cx="18" cy="16" r="3" />
          </svg>
          Listening
        </a>
        <a href="living-piece-playlist.html" class="nav-tab">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M21 15V6" />
            <path d="M18.5 18a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" />
            <path d="M12 12H3" />
            <path d="M16 6H3" />
            <path d="M12 18H3" />
          </svg>
          Playlist
        </a>
        <a href="admin.html" class="nav-tab">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"
            />
          </svg>
          Admin
        </a>
      </div>
    </nav>

    <!-- Track Toggle Button -->
    <button class="track-toggle" id="track-toggle" title="Browse tracks">
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="2"
      >
        <path d="M9 18V5l12-2v13" />
        <circle cx="6" cy="18" r="3" />
        <circle cx="18" cy="16" r="3" />
      </svg>
    </button>

    <!-- Drawer Backdrop -->
    <div class="drawer-backdrop" id="drawer-backdrop"></div>

    <!-- Track Drawer -->
    <div class="track-drawer" id="track-drawer">
      <div class="track-drawer-header">
        <span class="track-drawer-title">Tracks</span>
        <button class="track-drawer-close" id="track-drawer-close">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M18 6L6 18M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div class="track-list" id="track-list">
        <div class="track-list-loading">Loading tracks...</div>
      </div>
    </div>

    <div class="bg-layer"></div>

    <div class="particles" id="particles"></div>

    <div class="app">
      <div class="player-container">
        <!-- Main Player Panel -->
        <div class="panel album-section">
          <!-- Geometric Album Art -->
          <div class="album-art" id="album-art">
            <svg viewBox="0 0 400 400" xmlns="http://www.w3.org/2000/svg">
              <defs>
                <!-- Vibrant gradients -->
                <linearGradient
                  id="grad-orange"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #f97316; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #ea580c; stop-opacity: 1"
                  />
                </linearGradient>
                <linearGradient
                  id="grad-pink"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #ec4899; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #db2777; stop-opacity: 1"
                  />
                </linearGradient>
                <linearGradient
                  id="grad-blue"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #38bdf8; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #0ea5e9; stop-opacity: 1"
                  />
                </linearGradient>
                <linearGradient
                  id="grad-purple"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #a855f7; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #7c3aed; stop-opacity: 1"
                  />
                </linearGradient>
                <linearGradient
                  id="grad-teal"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #2dd4bf; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #14b8a6; stop-opacity: 1"
                  />
                </linearGradient>
                <linearGradient
                  id="grad-yellow"
                  x1="0%"
                  y1="0%"
                  x2="100%"
                  y2="100%"
                >
                  <stop
                    offset="0%"
                    style="stop-color: #fbbf24; stop-opacity: 1"
                  />
                  <stop
                    offset="100%"
                    style="stop-color: #f59e0b; stop-opacity: 1"
                  />
                </linearGradient>

                <filter id="glow-strong">
                  <feGaussianBlur stdDeviation="4" result="coloredBlur" />
                  <feMerge>
                    <feMergeNode in="coloredBlur" />
                    <feMergeNode in="SourceGraphic" />
                  </feMerge>
                </filter>
              </defs>

              <!-- Dark background -->
              <rect width="400" height="400" fill="#0a0a0a" />

              <!-- Large diagonal blocks -->
              <g class="geo-layer">
                <!-- Bottom left orange triangle -->
                <polygon
                  points="0,400 0,200 200,400"
                  fill="url(#grad-orange)"
                />

                <!-- Top right blue triangle -->
                <polygon points="400,0 400,200 200,0" fill="url(#grad-blue)" />

                <!-- Center pink diamond -->
                <polygon
                  points="200,80 320,200 200,320 80,200"
                  fill="url(#grad-pink)"
                  opacity="0.9"
                />
              </g>

              <!-- Layered geometric shapes -->
              <g class="geo-layer">
                <!-- Purple rectangle bar -->
                <rect
                  x="0"
                  y="160"
                  width="400"
                  height="80"
                  fill="url(#grad-purple)"
                  opacity="0.7"
                />

                <!-- Teal circle -->
                <circle
                  cx="320"
                  cy="320"
                  r="60"
                  fill="url(#grad-teal)"
                  opacity="0.85"
                />

                <!-- Yellow accent circle -->
                <circle
                  cx="80"
                  cy="80"
                  r="45"
                  fill="url(#grad-yellow)"
                  opacity="0.9"
                />
              </g>

              <!-- Bold line accents -->
              <g stroke-linecap="round" stroke-linejoin="round">
                <!-- Diagonal lines -->
                <line
                  x1="0"
                  y1="100"
                  x2="100"
                  y2="0"
                  stroke="#fff"
                  stroke-width="3"
                  opacity="0.3"
                />
                <line
                  x1="300"
                  y1="400"
                  x2="400"
                  y2="300"
                  stroke="#fff"
                  stroke-width="3"
                  opacity="0.3"
                />

                <!-- Cross lines through center -->
                <line
                  x1="200"
                  y1="120"
                  x2="200"
                  y2="280"
                  stroke="#fff"
                  stroke-width="2"
                  opacity="0.5"
                />
                <line
                  x1="120"
                  y1="200"
                  x2="280"
                  y2="200"
                  stroke="#fff"
                  stroke-width="2"
                  opacity="0.5"
                />
              </g>

              <!-- Inner geometric details -->
              <g class="geo-layer">
                <!-- Small inner diamond -->
                <polygon
                  points="200,160 240,200 200,240 160,200"
                  fill="#fff"
                  opacity="0.9"
                  filter="url(#glow-strong)"
                />

                <!-- Accent dots -->
                <circle cx="200" cy="200" r="8" fill="#0a0a0a" />
                <circle cx="140" cy="140" r="4" fill="#fff" opacity="0.7" />
                <circle cx="260" cy="260" r="4" fill="#fff" opacity="0.7" />
                <circle cx="140" cy="260" r="4" fill="#fff" opacity="0.7" />
                <circle cx="260" cy="140" r="4" fill="#fff" opacity="0.7" />
              </g>

              <!-- Outer frame lines -->
              <g fill="none" stroke-width="2">
                <rect
                  x="20"
                  y="20"
                  width="360"
                  height="360"
                  stroke="#fff"
                  opacity="0.1"
                  rx="4"
                />
                <rect
                  x="40"
                  y="40"
                  width="320"
                  height="320"
                  stroke="#fff"
                  opacity="0.05"
                  rx="2"
                />
              </g>

              <!-- Animated pulse ring (visible when playing) -->
              <circle
                class="pulse-ring"
                cx="200"
                cy="200"
                r="100"
                fill="none"
                stroke="url(#grad-blue)"
                stroke-width="2"
                opacity="0.4"
              />
            </svg>

            <div class="loading-overlay" id="loading-overlay">
              <div class="loader"></div>
            </div>
          </div>

          <!-- Track Info -->
          <div class="track-info">
            <div class="track-title">Living Piece</div>
            <div class="track-artist">Adaptive Composition</div>
            <div
              class="track-release"
              id="track-release-name"
              style="font-size: 12px; color: #505050; margin-top: 4px"
            ></div>
          </div>

          <!-- Context Chips -->
          <div class="context-row">
            <span class="chip">
              <svg
                class="chip-icon"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <circle cx="12" cy="12" r="10" />
                <polyline points="12,6 12,12 16,14" />
              </svg>
              <span id="chip-time">Morning</span>
            </span>
            <span class="chip">
              <svg
                class="chip-icon"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M6.34 17.66l-1.41 1.41M19.07 4.93l-1.41 1.41"
                />
                <circle cx="12" cy="12" r="5" />
              </svg>
              <span id="chip-weather">Sunny</span>
            </span>
            <span class="chip accent" id="chip-mode">
              <span id="chip-mode-text">Morning — Sunny</span>
            </span>
          </div>

          <!-- Progress Bar -->
          <div class="progress-container">
            <div class="progress-bar" id="progress-bar">
              <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="time-display">
              <span id="time-current">0:00</span>
              <span id="time-total">0:00</span>
            </div>
          </div>

          <!-- Transport Controls -->
          <div class="transport">
            <button
              class="btn btn-secondary"
              id="btn-prev"
              title="Previous variation"
            >
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z" />
              </svg>
            </button>

            <button class="btn btn-play" id="btn-play" title="Play">
              <svg viewBox="0 0 24 24" fill="currentColor" id="icon-play">
                <path d="M8 5v14l11-7z" />
              </svg>
              <svg
                viewBox="0 0 24 24"
                fill="currentColor"
                id="icon-pause"
                style="display: none"
              >
                <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z" />
              </svg>
            </button>

            <button
              class="btn btn-secondary"
              id="btn-next"
              title="Next variation"
            >
              <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
              </svg>
            </button>
          </div>

          <!-- Playback Mode -->
          <div class="mode-selector">
            <button class="mode-btn active" data-mode="fixed">Fixed</button>
            <button class="mode-btn" data-mode="dynamic">Dynamic</button>
            <button class="mode-btn" data-mode="dynamic_plus">
              + Surprises
            </button>
            <button
              class="instrumental-btn"
              id="btn-instrumental"
              title="Toggle Instrumental (mute vocals)"
            >
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z" />
                <path d="M19 10v2a7 7 0 01-14 0v-2" />
                <line x1="12" y1="19" x2="12" y2="23" />
                <line x1="8" y1="23" x2="16" y2="23" />
              </svg>
            </button>
            <button
              class="calm-btn"
              id="btn-calm"
              title="Toggle Calm Mode (mute rhythmic stems)"
            >
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
              </svg>
            </button>
          </div>

          <!-- Weather/Time Override -->
          <div class="controls-row">
            <div class="control-group">
              <div class="control-label">Weather</div>
              <div class="select-wrap">
                <select id="select-weather">
                  <option value="auto">Auto-detect</option>
                  <option value="sunny">Sunny</option>
                  <option value="rain">Rainy</option>
                  <option value="warm">Warm</option>
                  <option value="cold">Cold</option>
                </select>
              </div>
            </div>
            <div class="control-group">
              <div class="control-label">Time of Day</div>
              <div class="select-wrap">
                <select id="select-time">
                  <option value="auto">Auto-detect</option>
                  <option value="morning">Morning</option>
                  <option value="afternoon">Afternoon</option>
                  <option value="evening">Evening</option>
                  <option value="night">Night</option>
                </select>
              </div>
            </div>
          </div>

          <div class="status" id="status"></div>
        </div>

        <!-- Active Stems Panel -->
        <div class="panel stems-panel">
          <div class="stems-header">
            <span class="stems-title">Active Stems</span>
            <div style="display: flex; gap: 8px">
              <button
                class="regenerate-btn"
                id="btn-refresh"
                title="Clear cache and reload all audio"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M21 12a9 9 0 11-9-9c2.52 0 4.93 1 6.74 2.74L21 8" />
                  <path d="M21 3v5h-5" />
                </svg>
                Refresh
              </button>
              <button class="regenerate-btn" id="btn-regenerate">
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M23 4v6h-6M1 20v-6h6" />
                  <path
                    d="M3.51 9a9 9 0 0114.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0020.49 15"
                  />
                </svg>
                Regenerate
              </button>
            </div>
          </div>
          <div class="stems-grid" id="stems-grid">
            <!-- Populated by JS -->
          </div>
        </div>

        <!-- Saved Mixes Panel -->
        <div class="panel stems-panel">
          <div class="stems-header">
            <span class="stems-title">Saved Mixes</span>
            <button class="regenerate-btn" id="btn-save-mix">
              <svg
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                stroke-width="2"
              >
                <path
                  d="M19 21H5a2 2 0 01-2-2V5a2 2 0 012-2h11l5 5v11a2 2 0 01-2 2z"
                />
                <polyline points="17,21 17,13 7,13 7,21" />
                <polyline points="7,3 7,8 15,8" />
              </svg>
              Save Current
            </button>
          </div>

          <!-- Save dialog (hidden by default) -->
          <div class="save-dialog" id="save-dialog" style="display: none">
            <input
              type="text"
              id="mix-name-input"
              placeholder="Name this mix..."
              class="mix-name-input"
            />
            <div class="save-dialog-buttons">
              <button class="dialog-btn cancel" id="btn-cancel-save">
                Cancel
              </button>
              <button class="dialog-btn confirm" id="btn-confirm-save">
                Save
              </button>
            </div>
          </div>

          <div class="saved-mixes-list" id="saved-mixes-list">
            <!-- Populated by JS -->
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // SUPABASE SETUP
      // ============================================
      const supabaseUrl = "https://cimngwcwvbspkcqdzqfg.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNpbW5nd2N3dmJzcGtjcWR6cWZnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ1MzA1MDIsImV4cCI6MjA4MDEwNjUwMn0.L9Tvj4mlSjAtiSVMPkaegRF4laZl_E15ALZFdRhSzUg";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // ============================================
      // TRACK DRAWER
      // ============================================
      let availableTracks = [];
      let availableReleases = [];
      let currentTrackData = null;

      async function loadAvailableReleases() {
        const { data, error } = await supabase
          .from("releases")
          .select("*")
          .eq("is_active", true)
          .order("sort_order");

        if (!error && data) {
          availableReleases = data;
        }
      }

      async function loadAvailableTracks() {
        const trackListEl = document.getElementById("track-list");
        trackListEl.innerHTML =
          '<div class="track-list-loading">Loading tracks...</div>';

        // Load releases first
        await loadAvailableReleases();

        const { data, error } = await supabase
          .from("tracks")
          .select("*")
          .eq("is_active", true)
          .order("title");

        if (error) {
          trackListEl.innerHTML =
            '<div class="track-list-empty">Failed to load tracks</div>';
          console.error("Error loading tracks:", error);
          return;
        }

        availableTracks = data || [];
        renderTrackList();
      }

      function renderTrackList() {
        const trackListEl = document.getElementById("track-list");

        // Add the built-in demo track first
        let html = `
    <div class="track-list-item ${!usingDatabaseTrack ? "active" : ""}" 
         data-track-id="demo" 
         onclick="selectDemoTrack()">
      <div class="track-list-title">Living Piece (Demo)</div>
      <div class="track-list-meta">
        <span>Built-in</span>
      </div>
    </div>
  `;

        if (availableTracks.length === 0) {
          html +=
            '<div class="track-list-empty" style="padding: 20px 10px;">No custom tracks yet.<br>Create one in Admin.</div>';
        } else {
          html += availableTracks
            .map((track) => {
              const release = availableReleases.find(
                (r) => r.id === track.release_id
              );
              const releaseName = release ? release.title : "";
              return `
        <div class="track-list-item ${
          currentTrackData?.id === track.id ? "active" : ""
        }" 
             data-track-id="${track.id}" 
             onclick="selectTrack('${track.id}')">
          <div class="track-list-title">${escapeHtml(track.title)}</div>
          <div class="track-list-meta">
            <span>${track.bpm || "?"} BPM</span>
            ${track.base_key ? `<span>${track.base_key}</span>` : ""}
            ${
              releaseName
                ? `<span style="color: #0ea5e9;">${escapeHtml(
                    releaseName
                  )}</span>`
                : ""
            }
          </div>
        </div>
      `;
            })
            .join("");
        }

        trackListEl.innerHTML = html;
      }

      // Function to select the built-in demo track
      function selectDemoTrack() {
        // Stop current playback
        stop(false);

        // Reset to demo mode
        usingDatabaseTrack = false;
        currentTrackData = null;

        // Clear players
        Object.values(players).forEach((p) => {
          try {
            p.disconnect();
            p.dispose();
          } catch {}
        });
        players = {};
        loadedBuffers.clear();
        usedTakesHistory = {}; // Reset alternation history for new track

        // Reset to default config
        modes.length = 0;
        modes.push(
          {
            id: "ms",
            slug: "morning_sunny",
            label: "Morning — Sunny",
            time: "morning",
            weather: "sunny",
          },
          {
            id: "mr",
            slug: "morning_rainy",
            label: "Morning — Rainy",
            time: "morning",
            weather: "rain",
          },
          {
            id: "nf",
            slug: "night_firelight",
            label: "Night — Firelight",
            time: "night",
            weather: "warm",
          },
          {
            id: "nc",
            slug: "night_cold",
            label: "Night — Cold",
            time: "night",
            weather: "cold",
          }
        );

        stemGroups.length = 0;
        stemGroups.push(
          {
            id: "guitar",
            role: "Guitar",
            category: "core",
            canSurprise: false,
          },
          { id: "piano", role: "Piano", category: "core", canSurprise: false },
          {
            id: "drums",
            role: "Drums",
            category: "secondary",
            canSurprise: false,
          },
          {
            id: "vocal",
            role: "Vocal",
            category: "secondary",
            canSurprise: false,
          },
          {
            id: "pad",
            role: "Pad Texture",
            category: "secondary",
            canSurprise: false,
          },
          {
            id: "strings",
            role: "Strings",
            category: "secondary",
            canSurprise: false,
          },
          {
            id: "snack",
            role: "Snack Layer",
            category: "snack",
            canSurprise: true,
          }
        );

        takes = takesConfig.map((t) => ({ ...t, url: getAudioUrl(t.file) }));

        // Update UI
        document.querySelector(".track-title").textContent = "Living Piece";
        document.querySelector(".track-artist").textContent =
          "Adaptive Composition";

        // Clear release name
        const releaseNameEl = document.getElementById("track-release-name");
        if (releaseNameEl) releaseNameEl.textContent = "";

        // Reset album art to default SVG
        resetAlbumArt();

        // Duration will be detected from audio when played
        dom.timeTotal.textContent = formatTime(0);

        // Update track list highlight
        renderTrackList();

        // Update saved mixes for demo track
        renderSavedMixes();

        // Close drawer
        closeTrackDrawer();

        // Build selection
        buildSelection();

        setStatus("Demo track loaded", "success");
      }

      async function selectTrack(trackId) {
        const track = availableTracks.find((t) => t.id === trackId);
        if (!track) return;

        // Stop current playback
        stop(false);

        // Set loading state
        setStatus("Loading track...", "");
        setLoading(true);

        // Load track data from Supabase
        const [modesRes, groupsRes] = await Promise.all([
          supabase
            .from("modes")
            .select("*")
            .eq("track_id", trackId)
            .order("sort_order"),
          supabase
            .from("stem_groups")
            .select("*")
            .eq("track_id", trackId)
            .order("role"),
        ]);

        if (modesRes.error || groupsRes.error) {
          setStatus("Failed to load track data", "error");
          setLoading(false);
          return;
        }

        const trackModes = modesRes.data || [];
        const trackGroups = groupsRes.data || [];

        // Load takes for all groups
        let trackTakes = [];
        if (trackGroups.length > 0) {
          const groupIds = trackGroups.map((g) => g.id);
          const { data: takesData } = await supabase
            .from("stem_takes")
            .select("*")
            .in("stem_group_id", groupIds)
            .eq("is_enabled", true);
          trackTakes = takesData || [];
        }

        // Update current track data
        currentTrackData = track;
        usingDatabaseTrack = true; // Mark that we're using a database track

        // Clear old audio cache BEFORE updating config
        // This disposes old players but won't reset takes yet
        Object.values(players).forEach((p) => {
          try {
            p.disconnect();
            p.dispose();
          } catch {}
        });
        players = {};
        loadedBuffers.clear();
        usedTakesHistory = {}; // Reset alternation history for new track

        // Update configuration from database (this sets the new takes)
        updateConfigFromTrack(track, trackModes, trackGroups, trackTakes);

        // Update UI
        document.querySelector(".track-title").textContent = track.title;
        document.querySelector(".track-artist").textContent =
          track.description || "Adaptive Composition";

        // Show release name
        const release = availableReleases.find(
          (r) => r.id === track.release_id
        );
        const releaseNameEl = document.getElementById("track-release-name");
        if (releaseNameEl) {
          releaseNameEl.textContent = release ? release.title : "";
        }

        // Update album art - use track cover, then release cover, then keep default SVG
        updateAlbumArt(track, release);

        // Use database duration as initial estimate, will be updated from actual audio
        if (track.length_seconds) {
          trackDuration = track.length_seconds;
          dom.timeTotal.textContent = formatTime(trackDuration);
        } else {
          dom.timeTotal.textContent = formatTime(0);
        }

        // Update track list highlight
        renderTrackList();

        // Update saved mixes for this track
        renderSavedMixes();

        // Close drawer
        closeTrackDrawer();

        // Build new selection with loaded stems
        buildSelection();

        setLoading(false);

        // Show what was loaded
        const stemCount = Object.keys(currentSelection).length;
        if (stemCount > 0) {
          setStatus(
            `Loaded "${track.title}" with ${stemCount} stems`,
            "success"
          );
        } else if (trackTakes.length === 0) {
          setStatus(`"${track.title}" has no stems uploaded yet`, "error");
        } else {
          setStatus(
            `Loaded "${track.title}" - ${trackTakes.length} takes available`,
            "success"
          );
        }
      }

      // Store the default SVG so we can restore it
      const defaultAlbumArtSVG =
        document.getElementById("album-art")?.innerHTML || "";

      function updateAlbumArt(track, release) {
        const albumArtEl = document.getElementById("album-art");
        if (!albumArtEl) return;

        // Check for track cover first, then release cover
        let coverUrl = track?.cover_image_url;
        if (!coverUrl && release?.cover_image_url) {
          coverUrl = release.cover_image_url;
        }

        if (coverUrl) {
          // Use the uploaded cover image
          albumArtEl.innerHTML = `<img src="${escapeHtml(
            coverUrl
          )}" alt="${escapeHtml(
            track?.title || "Cover"
          )}" style="width: 100%; height: 100%; object-fit: cover; border-radius: inherit;" />`;
        } else {
          // Restore the default SVG
          albumArtEl.innerHTML = defaultAlbumArtSVG;
        }
      }

      function resetAlbumArt() {
        const albumArtEl = document.getElementById("album-art");
        if (albumArtEl && defaultAlbumArtSVG) {
          albumArtEl.innerHTML = defaultAlbumArtSVG;
        }
      }

      function updateConfigFromTrack(
        track,
        trackModes,
        trackGroups,
        trackTakes
      ) {
        // Update modes
        modes.length = 0;
        trackModes.forEach((m) => {
          modes.push({
            id: m.slug || m.id,
            slug: m.slug,
            label: m.label,
            time: m.time_of_day,
            weather: m.weather_tag,
          });
        });

        // If no modes defined, use defaults
        if (modes.length === 0) {
          modes.push({
            id: "default",
            slug: "default",
            label: "Default",
            time: null,
            weather: null,
          });
        }

        // Update stem groups
        stemGroups.length = 0;
        trackGroups.forEach((g) => {
          stemGroups.push({
            id: g.id,
            role: g.display_name || g.role,
            category: g.category || "secondary",
            canSurprise: g.can_be_surprise || false,
            isRequired: g.is_required !== false, // default to true
            isRhythmic: g.is_rhythmic || false,
          });
        });

        // Update takes - build from database takes
        takes.length = 0;

        // Map of mode_id to mode data for lookup
        const modeMap = {};
        trackModes.forEach((m) => {
          modeMap[m.id] = m;
        });

        // Map of group_id to group data for lookup
        const groupMap = {};
        trackGroups.forEach((g) => {
          groupMap[g.id] = g;
        });

        trackTakes.forEach((t) => {
          const group = groupMap[t.stem_group_id];
          const mode = t.mode_id ? modeMap[t.mode_id] : null;

          // Determine time period from mode
          let timePeriod = null;
          if (mode && mode.time_of_day) {
            if (
              mode.time_of_day === "morning" ||
              mode.time_of_day === "afternoon"
            ) {
              timePeriod = "day";
            } else if (
              mode.time_of_day === "evening" ||
              mode.time_of_day === "night"
            ) {
              timePeriod = "night";
            }
          }

          // Determine weather from mode
          let weather = undefined;
          if (mode && mode.weather_tag) {
            if (mode.weather_tag === "sunny" || mode.weather_tag === "warm") {
              weather = "warm";
            } else if (
              mode.weather_tag === "rain" ||
              mode.weather_tag === "cold"
            ) {
              weather = "cold";
            }
          }

          // Decode URL so Tone.js can re-encode it properly
          // Database has %20, we decode to space, Tone.js encodes back to %20
          let audioUrl = t.audio_url || "";
          try {
            audioUrl = decodeURIComponent(audioUrl);
          } catch (e) {
            // If decode fails, use original
          }

          takes.push({
            id: t.id,
            group: group?.id || t.stem_group_id,
            groupRole: group?.role || "unknown",
            time: timePeriod,
            weather: weather,
            modeId: t.mode_id,
            file: getFileNameFromUrl(audioUrl),
            url: audioUrl + getCacheBuster(),
            weight: t.weight || 1,
          });
        });

        console.log("Track config updated:", {
          modes: modes.length,
          stemGroups: stemGroups.length,
          takes: takes.length,
        });
      }

      function getFileNameFromUrl(url) {
        if (!url) return "";
        return url.split("/").pop().split("?")[0];
      }

      // Drawer toggle functions
      function openTrackDrawer() {
        document.getElementById("track-drawer").classList.add("open");
        document.getElementById("drawer-backdrop").classList.add("visible");
        document.getElementById("track-toggle").classList.add("active");
      }

      function closeTrackDrawer() {
        document.getElementById("track-drawer").classList.remove("open");
        document.getElementById("drawer-backdrop").classList.remove("visible");
        document.getElementById("track-toggle").classList.remove("active");
      }

      function toggleTrackDrawer() {
        const drawer = document.getElementById("track-drawer");
        if (drawer.classList.contains("open")) {
          closeTrackDrawer();
        } else {
          openTrackDrawer();
        }
      }

      // Event listeners for drawer
      document
        .getElementById("track-toggle")
        .addEventListener("click", toggleTrackDrawer);
      document
        .getElementById("track-drawer-close")
        .addEventListener("click", closeTrackDrawer);
      document
        .getElementById("drawer-backdrop")
        .addEventListener("click", closeTrackDrawer);

      // ============================================
      // CONFIGURATION
      // ============================================
      const BASE =
        "https://cimngwcwvbspkcqdzqfg.supabase.co/storage/v1/object/public/audio/living_piece";

      // Cache buster - generates fresh timestamp for each audio request
      function getCacheBuster() {
        return `?v=${Date.now()}&r=${Math.random().toString(36).substr(2, 9)}`;
      }

      // Modes configuration (can be overridden by track data)
      let modes = [
        {
          id: "ms",
          slug: "morning_sunny",
          label: "Morning — Sunny",
          time: "morning",
          weather: "sunny",
        },
        {
          id: "mr",
          slug: "morning_rainy",
          label: "Morning — Rainy",
          time: "morning",
          weather: "rain",
        },
        {
          id: "nf",
          slug: "night_firelight",
          label: "Night — Firelight",
          time: "night",
          weather: "warm",
        },
        {
          id: "nc",
          slug: "night_cold",
          label: "Night — Cold",
          time: "night",
          weather: "cold",
        },
      ];

      // Stem groups (can be overridden by track data)
      let stemGroups = [
        { id: "guitar", role: "Guitar", category: "core", canSurprise: false },
        { id: "piano", role: "Piano", category: "core", canSurprise: false },
        {
          id: "drums",
          role: "Drums",
          category: "secondary",
          canSurprise: false,
        },
        {
          id: "vocal",
          role: "Vocal",
          category: "secondary",
          canSurprise: false,
        },
        {
          id: "pad",
          role: "Pad Texture",
          category: "secondary",
          canSurprise: false,
        },
        {
          id: "strings",
          role: "Strings",
          category: "secondary",
          canSurprise: false,
        },
        {
          id: "snack",
          role: "Snack Layer",
          category: "snack",
          canSurprise: true,
        },
      ];

      // Takes - filenames in Supabase bucket
      // URLs are generated dynamically with cache busting in getAudioUrl()
      function getAudioUrl(filename) {
        return `${BASE}/${filename}${getCacheBuster()}`;
      }

      const takesConfig = [
        // Day Guitar (morning/afternoon)
        {
          id: "day_g1",
          group: "guitar",
          time: "day",
          file: "secondary_guitar_t1.wav",
        },
        {
          id: "day_g2",
          group: "guitar",
          time: "day",
          file: "secondary_guitar_t2.wav",
        },

        // Night Guitar (evening/night)
        {
          id: "night_g1",
          group: "guitar",
          time: "night",
          file: "primary_guitar_t1.wav",
        },
        {
          id: "night_g2",
          group: "guitar",
          time: "night",
          file: "primary_guitar_t2.wav",
        },

        // Day Piano (morning/afternoon)
        {
          id: "day_p1",
          group: "piano",
          time: "day",
          file: "night_firelight_main_piano_t1.wav",
        },
        {
          id: "day_p2",
          group: "piano",
          time: "day",
          file: "night_firelight_main_piano_t2.wav",
        },

        // Night Piano (evening/night)
        {
          id: "night_p1",
          group: "piano",
          time: "night",
          file: "night_cold_main_piano_t1.wav",
        },
        {
          id: "night_p2",
          group: "piano",
          time: "night",
          file: "night_cold_main_piano_t2.wav",
        },

        // Drums - only play in sunny/warm weather
        {
          id: "drums1",
          group: "drums",
          time: null,
          weather: "warm",
          file: "drumloop1.wav",
        },
        {
          id: "drums2",
          group: "drums",
          time: null,
          weather: "warm",
          file: "drumloop2.wav",
        },

        // Vocals - day vocal for day+warm, night vocal for night+warm
        {
          id: "vox_day",
          group: "vocal",
          time: "day",
          weather: "warm",
          file: "vox_day_t1.wav",
        },
        {
          id: "vox_night",
          group: "vocal",
          time: "night",
          weather: "warm",
          file: "vox_night_t1.wav",
        },

        // Pad textures - play anytime
        { id: "pad1", group: "pad", time: null, file: "pad_texture_t1.wav" },
        { id: "pad2", group: "pad", time: null, file: "pad_texture_t2.wav" },

        // Strings - only night + cold
        {
          id: "strings1",
          group: "strings",
          time: "night",
          weather: "cold",
          file: "strings_night_cold_t1.wav",
        },

        // Snack layers
        {
          id: "sn1",
          group: "snack",
          time: null,
          file: "snack_layer_swells_t1.wav",
        },
        {
          id: "sn2",
          group: "snack",
          time: null,
          file: "snack_layer_reverse_t2.wav",
        },
      ];

      // Generate takes with fresh URLs (only used for default/demo track)
      let takes = takesConfig.map((t) => ({ ...t, url: getAudioUrl(t.file) }));

      // Flag to track if we're using database track or default
      let usingDatabaseTrack = false;

      // ============================================
      // STATE
      // ============================================
      let currentWeatherOverride = "auto";
      let currentTimeOverride = "auto";
      let currentMode = null;
      let currentSelection = {};
      let currentPlaybackMode = "fixed";
      let instrumentalMode = false; // Mutes VOX category stems
      let calmMode = false; // Mutes rhythmic/intense stems
      let isPlaying = false;
      let isLoading = false;
      let players = {};
      let loadedBuffers = new Set();
      let trackDuration = 0; // Will be detected from loaded audio stems
      let savedMixes = []; // Array of saved mix configurations
      let usedTakesHistory = {}; // Track used takes per group for full-cycle alternation
      let voxGainNodes = {}; // Store gain nodes for VOX stems to mute/unmute
      let rhythmicGainNodes = {}; // Store gain nodes for rhythmic stems to mute/unmute in calm mode

      // ============================================
      // SAVED MIXES - localStorage
      // ============================================
      const STORAGE_KEY = "livingPiece_savedMixes";

      function loadSavedMixes() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            savedMixes = JSON.parse(stored);
          }
        } catch (e) {
          console.error("Failed to load saved mixes:", e);
          savedMixes = [];
        }
      }

      function saveMixesToStorage() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(savedMixes));
        } catch (e) {
          console.error("Failed to save mixes:", e);
        }
      }

      function createSavedMix(name) {
        const mix = {
          id: Date.now().toString(),
          name: name || `Mix ${savedMixes.length + 1}`,
          createdAt: new Date().toISOString(),
          trackId: currentTrackData?.id || "demo", // Track ID or 'demo' for built-in
          trackTitle: currentTrackData?.title || "Living Piece",
          mode: currentMode,
          playbackMode: currentPlaybackMode,
          timeOverride: currentTimeOverride,
          weatherOverride: currentWeatherOverride,
          selection: { ...currentSelection },
        };

        savedMixes.unshift(mix); // Add to beginning
        saveMixesToStorage();
        renderSavedMixes();
        return mix;
      }

      function deleteSavedMix(mixId) {
        savedMixes = savedMixes.filter((m) => m.id !== mixId);
        saveMixesToStorage();
        renderSavedMixes();
      }

      function loadSavedMix(mixId) {
        const mix = savedMixes.find((m) => m.id === mixId);
        if (!mix) return;

        // Stop any current playback immediately
        stopImmediate();

        // Restore settings
        currentMode = mix.mode;
        currentPlaybackMode = mix.playbackMode;
        currentTimeOverride = mix.timeOverride;
        currentWeatherOverride = mix.weatherOverride;
        currentSelection = { ...mix.selection };

        // Update UI controls
        document.getElementById("select-time").value = mix.timeOverride;
        document.getElementById("select-weather").value = mix.weatherOverride;

        // Update mode buttons
        document.querySelectorAll(".mode-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.mode === mix.playbackMode);
        });

        // Regenerate URLs for the selection (cache busting)
        for (const groupId in currentSelection) {
          const take = currentSelection[groupId];
          if (take && take.url) {
            // Strip old cache buster and add new one
            const baseUrl = take.url.split("?")[0];
            take.url = baseUrl + getCacheBuster();
          } else if (take && take.file) {
            // Fallback for old saved mixes that only have file (demo track)
            take.url = getAudioUrl(take.file);
          }
        }

        updateUI();

        // Always play the loaded mix
        play(false);
      }

      function renderSavedMixes() {
        const container = document.getElementById("saved-mixes-list");

        // Filter mixes for current track
        const currentTrackId = currentTrackData?.id || "demo";
        const trackMixes = savedMixes.filter((mix) => {
          // Show mixes that match current track, or old mixes without trackId (legacy) when on demo
          if (mix.trackId) {
            return mix.trackId === currentTrackId;
          }
          // Legacy mixes without trackId - only show on demo track
          return currentTrackId === "demo";
        });

        if (trackMixes.length === 0) {
          container.innerHTML =
            '<div class="empty-state">No saved mixes for this track</div>';
          return;
        }

        container.innerHTML = trackMixes
          .map((mix) => {
            const date = new Date(mix.createdAt);
            const dateStr = date.toLocaleDateString(undefined, {
              month: "short",
              day: "numeric",
            });
            const stemCount = Object.keys(mix.selection).length;

            return `
      <div class="saved-mix-item" data-mix-id="${mix.id}">
        <div class="saved-mix-info">
          <div class="saved-mix-name">${escapeHtml(mix.name)}</div>
          <div class="saved-mix-meta">${stemCount} stems · ${
              mix.mode?.label || "Unknown"
            } · ${dateStr}</div>
        </div>
        <div class="saved-mix-actions">
          <button class="mix-action-btn play" title="Load this mix" data-action="load">
            <svg viewBox="0 0 24 24" fill="currentColor">
              <path d="M8 5v14l11-7z"/>
            </svg>
          </button>
          <button class="mix-action-btn delete" title="Delete this mix" data-action="delete">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M3 6h18M19 6v14a2 2 0 01-2 2H7a2 2 0 01-2-2V6m3 0V4a2 2 0 012-2h4a2 2 0 012 2v2"/>
            </svg>
          </button>
        </div>
      </div>
    `;
          })
          .join("");

        // Add event listeners
        container.querySelectorAll(".mix-action-btn").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            const mixId = btn.closest(".saved-mix-item").dataset.mixId;
            const action = btn.dataset.action;

            if (action === "load") {
              loadSavedMix(mixId);
            } else if (action === "delete") {
              deleteSavedMix(mixId);
              setStatus("Mix deleted", "");
            }
          });
        });
      }

      function escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      // ============================================
      // DOM REFERENCES
      // ============================================
      const dom = {
        albumArt: document.getElementById("album-art"),
        loadingOverlay: document.getElementById("loading-overlay"),
        chipTime: document.getElementById("chip-time"),
        chipWeather: document.getElementById("chip-weather"),
        chipModeText: document.getElementById("chip-mode-text"),
        progressBar: document.getElementById("progress-bar"),
        progressFill: document.getElementById("progress-fill"),
        timeCurrent: document.getElementById("time-current"),
        timeTotal: document.getElementById("time-total"),
        btnPlay: document.getElementById("btn-play"),
        iconPlay: document.getElementById("icon-play"),
        iconPause: document.getElementById("icon-pause"),
        btnPrev: document.getElementById("btn-prev"),
        btnNext: document.getElementById("btn-next"),
        btnRegenerate: document.getElementById("btn-regenerate"),
        selectWeather: document.getElementById("select-weather"),
        selectTime: document.getElementById("select-time"),
        stemsGrid: document.getElementById("stems-grid"),
        status: document.getElementById("status"),
        modeBtns: document.querySelectorAll(".mode-btn"),
      };

      // ============================================
      // UTILITIES
      // ============================================
      function getTimeOfDay() {
        if (currentTimeOverride !== "auto") return currentTimeOverride;
        const h = new Date().getHours();
        if (h >= 5 && h < 12) return "morning";
        if (h >= 12 && h < 17) return "afternoon";
        if (h >= 17 && h < 22) return "evening";
        return "night";
      }

      function getWeather() {
        if (currentWeatherOverride !== "auto") return currentWeatherOverride;
        // Mock weather - in production, use actual weather API
        const weathers = ["sunny", "rain", "warm", "cold"];
        return weathers[Math.floor(Math.random() * weathers.length)];
      }

      function randomItem(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function setStatus(msg, type = "") {
        dom.status.textContent = msg;
        dom.status.className = "status " + type;
      }

      function setLoading(loading) {
        isLoading = loading;
        dom.loadingOverlay.classList.toggle("active", loading);
      }

      // ============================================
      // MODE SELECTION
      // ============================================
      function pickMode() {
        const tod = getTimeOfDay();
        const weather = getWeather();

        // Try exact match
        let mode = modes.find((m) => m.time === tod && m.weather === weather);

        // Fallback to same time of day
        if (!mode) {
          mode = modes.find((m) => m.time === tod);
        }

        // Ultimate fallback
        if (!mode) {
          mode = modes[0];
        }

        return mode;
      }

      // ============================================
      // STEM SELECTION
      // ============================================
      function buildSelection() {
        currentMode = pickMode();
        const timeOfDay = getTimeOfDay();
        const weather = getWeather();
        currentSelection = {};

        // Determine time period
        const isNightTime = timeOfDay === "night" || timeOfDay === "evening";
        const timePeriod = isNightTime ? "night" : "day";

        // Determine if weather is "warm" (sunny/warm) or "cold" (rain/cold)
        const isWarmWeather = weather === "sunny" || weather === "warm";
        const isColdWeather = weather === "rain" || weather === "cold";

        // If we have no takes loaded, nothing to do
        if (takes.length === 0) {
          console.log("No takes available for selection");
          updateUI();
          return;
        }

        // Check if we're in a dynamic mode (should alternate takes)
        const shouldAlternate =
          currentPlaybackMode === "dynamic" ||
          currentPlaybackMode === "dynamic_plus";

        // In surprises mode, occasionally trigger instrumental (15% chance)
        let surpriseInstrumental = false;
        if (
          currentPlaybackMode === "dynamic_plus" &&
          !instrumentalMode &&
          Math.random() < 0.15
        ) {
          surpriseInstrumental = true;
        }

        // Select stems for each group
        for (const group of stemGroups) {
          // Skip snack layers unless in dynamic_plus mode
          if (group.category === "snack") {
            if (currentPlaybackMode === "dynamic_plus" && Math.random() > 0.5) {
              const snackTakes = takes.filter((t) => t.group === group.id);
              if (snackTakes.length) {
                currentSelection[group.id] = selectTakeWithAlternation(
                  snackTakes,
                  group.id,
                  shouldAlternate
                );
              }
            }
            continue;
          }

          // Skip VOX if instrumental mode or surprise instrumental
          if (
            group.category === "vox" &&
            (instrumentalMode || surpriseInstrumental)
          ) {
            continue;
          }

          // Get all takes for this group
          const groupTakes = takes.filter((t) => t.group === group.id);

          if (groupTakes.length === 0) continue;

          // Filter by time and weather constraints
          let validTakes = groupTakes.filter((t) => {
            // Check time constraint - if take has a time restriction, it must match
            if (
              t.time !== null &&
              t.time !== undefined &&
              t.time !== timePeriod
            ) {
              return false;
            }

            // Check weather constraint - if take has a weather restriction, it must match
            if (t.weather !== undefined && t.weather !== null) {
              if (t.weather === "warm" && !isWarmWeather) return false;
              if (t.weather === "cold" && !isColdWeather) return false;
            }

            return true;
          });

          // If no takes match current conditions, fall back to any take from this group
          if (validTakes.length === 0) {
            validTakes = groupTakes;
          }

          // Select a take (with alternation in dynamic mode)
          if (validTakes.length > 0) {
            currentSelection[group.id] = selectTakeWithAlternation(
              validTakes,
              group.id,
              shouldAlternate
            );
          }
        }

        // Update usedTakesHistory for next regeneration
        for (const groupId in currentSelection) {
          const takeId = currentSelection[groupId].id;
          if (!usedTakesHistory[groupId]) {
            usedTakesHistory[groupId] = [];
          }
          usedTakesHistory[groupId].push(takeId);
        }

        console.log(
          "Selection built:",
          Object.keys(currentSelection).length,
          "stems",
          shouldAlternate ? "(cycling)" : "(fixed)"
        );
        updateUI();
      }

      // Select a take, cycling through all takes before any can repeat
      function selectTakeWithAlternation(validTakes, groupId, shouldAlternate) {
        // If only one take or not alternating, use weighted random
        if (validTakes.length === 1 || !shouldAlternate) {
          return weightedRandomTake(validTakes);
        }

        // Get history for this group
        const history = usedTakesHistory[groupId] || [];

        // Get IDs of valid takes
        const validTakeIds = validTakes.map((t) => t.id);

        // Filter out takes that have been used in current cycle
        // A "cycle" resets when all valid takes have been played
        let availableTakes = validTakes.filter((t) => !history.includes(t.id));

        // If all takes have been used, reset the cycle for this group
        // But keep the most recent one excluded to avoid immediate repeat
        if (availableTakes.length === 0) {
          // Reset history but remember the last played take
          const lastPlayed = history[history.length - 1];
          usedTakesHistory[groupId] = lastPlayed ? [lastPlayed] : [];

          // Now all except the last one are available
          availableTakes = validTakes.filter((t) => t.id !== lastPlayed);

          // Edge case: if still empty (only 1 take), use all
          if (availableTakes.length === 0) {
            availableTakes = validTakes;
          }

          console.log(
            `Cycle reset for group ${groupId}: ${validTakes.length} takes available`
          );
        }

        return weightedRandomTake(availableTakes);
      }

      // Weighted random selection from takes
      function weightedRandomTake(takes) {
        if (takes.length === 0) return null;
        if (takes.length === 1) return takes[0];

        const totalWeight = takes.reduce((sum, t) => sum + (t.weight || 1), 0);
        let random = Math.random() * totalWeight;

        for (const take of takes) {
          random -= take.weight || 1;
          if (random <= 0) {
            return take;
          }
        }

        // Fallback
        return takes[Math.floor(Math.random() * takes.length)];
      }

      // ============================================
      // AUDIO ENGINE
      // ============================================

      const CROSSFADE_DURATION = 1; // seconds
      let masterGain = null;
      let isTransitioning = false;

      // Initialize master gain
      function initAudio() {
        if (!masterGain) {
          masterGain = new Tone.Gain(1).toDestination();
        }
      }

      // Clear all cached players and regenerate URLs
      function clearAudioCache() {
        // Stop everything
        stopImmediate();

        // Dispose all existing players
        Object.values(players).forEach((p) => {
          try {
            p.disconnect();
            p.dispose();
          } catch {}
        });

        // Reset player cache
        players = {};
        loadedBuffers.clear();

        // Only regenerate from takesConfig if NOT using a database track
        // Database tracks have their takes set in updateConfigFromTrack()
        if (!usingDatabaseTrack) {
          takes = takesConfig.map((t) => ({ ...t, url: getAudioUrl(t.file) }));
        } else {
          // Just refresh the cache busters on existing takes
          takes = takes.map((t) => {
            // Extract base URL without query params and add fresh cache buster
            const baseUrl = t.url.split("?")[0];
            return { ...t, url: baseUrl + getCacheBuster() };
          });
        }

        console.log(
          "Audio cache cleared, URLs refreshed. Using database track:",
          usingDatabaseTrack
        );
      }

      // Stop immediately without fade
      function stopImmediate() {
        isTransitioning = false;

        Tone.Transport.stop();
        Tone.Transport.position = 0;
        Tone.Transport.cancel(); // Clear all scheduled events

        // Stop all players
        Object.values(players).forEach((p) => {
          try {
            p.stop();
            p.unsync();
          } catch {}
        });

        // Reset master gain
        if (masterGain) {
          masterGain.gain.cancelScheduledValues(Tone.now());
          masterGain.gain.value = 1;
        }

        isPlaying = false;
        updatePlayButton();
        dom.albumArt.classList.remove("playing");
        dom.progressFill.style.width = "0%";
        dom.timeCurrent.textContent = "0:00";
      }

      async function loadPlayers() {
        setLoading(true);
        setStatus("Loading audio...");

        try {
          await Tone.start();
          initAudio();

          const selectedTakes = Object.values(currentSelection);
          const loadPromises = [];

          for (const take of selectedTakes) {
            if (!players[take.id]) {
              // Check stem properties
              const group = stemGroups.find((g) => g.id === take.group);
              const isVox = group?.category === "vox";
              const isRhythmic = group?.isRhythmic || false;

              // Load audio using fetch to bypass Tone.js URL encoding issues
              const loadPromise = (async () => {
                try {
                  const response = await fetch(take.url);
                  if (!response.ok) throw new Error(`HTTP ${response.status}`);
                  const arrayBuffer = await response.arrayBuffer();
                  const audioBuffer = await Tone.context.decodeAudioData(
                    arrayBuffer
                  );

                  const player = new Tone.Player(audioBuffer);

                  // Route through gain nodes for muting capabilities
                  let outputNode = masterGain;

                  // Rhythmic stems get their own gain node (for calm mode)
                  if (isRhythmic) {
                    const rhythmicGain = new Tone.Gain(
                      calmMode ? 0 : 1
                    ).connect(outputNode);
                    rhythmicGainNodes[take.group] = rhythmicGain;
                    outputNode = rhythmicGain;
                  }

                  // VOX stems get their own gain node (for instrumental mode)
                  if (isVox) {
                    const voxGain = new Tone.Gain(
                      instrumentalMode ? 0 : 1
                    ).connect(outputNode);
                    voxGainNodes[take.group] = voxGain;
                    outputNode = voxGain;
                  }

                  player.connect(outputNode);

                  players[take.id] = player;
                  loadedBuffers.add(take.id);
                } catch (err) {
                  console.error(`Failed to load ${take.url}:`, err);
                }
              })();

              loadPromises.push(loadPromise);
            }
          }

          if (loadPromises.length > 0) {
            await Promise.all(loadPromises);
          }

          // Get duration from the first successfully loaded player
          updateDurationFromLoadedStems();

          setLoading(false);
          setStatus("Ready", "success");
          return true;
        } catch (err) {
          console.error("Audio loading error:", err);
          setLoading(false);
          setStatus("Failed to load audio", "error");
          return false;
        }
      }

      // Get track duration from any loaded stem (they should all be the same length)
      function updateDurationFromLoadedStems() {
        for (const takeId in players) {
          const player = players[takeId];
          if (player && player.buffer && player.buffer.duration > 0) {
            trackDuration = player.buffer.duration;
            dom.timeTotal.textContent = formatTime(trackDuration);
            console.log(
              "Track duration from audio:",
              trackDuration.toFixed(2) + "s"
            );
            return;
          }
        }
      }

      async function play(withCrossfade = false) {
        if (isLoading || isTransitioning) return;

        if (withCrossfade && isPlaying) {
          // Simple crossfade: fade out master, stop, load new, start, fade in
          isTransitioning = true;
          setStatus("Crossfading...", "");

          // Fade out
          masterGain.gain.rampTo(0, CROSSFADE_DURATION);

          // Wait for fade out
          await new Promise((resolve) =>
            setTimeout(resolve, CROSSFADE_DURATION * 1000)
          );

          if (!isTransitioning) return; // Cancelled

          // Stop old players
          Tone.Transport.stop();
          Tone.Transport.position = 0;
          Tone.Transport.cancel();
          Object.values(players).forEach((p) => {
            try {
              p.stop();
              p.unsync();
            } catch {}
          });

          // Load new players
          const loaded = await loadPlayers();
          if (!loaded || !isTransitioning) {
            isTransitioning = false;
            return;
          }

          // Start new players
          Tone.Transport.position = 0;
          for (const groupId in currentSelection) {
            const take = currentSelection[groupId];
            const player = players[take.id];
            if (player && player.loaded) {
              player.sync().start(0);
            }
          }
          Tone.Transport.start();

          // Fade in
          masterGain.gain.rampTo(1, CROSSFADE_DURATION);

          isTransitioning = false;
          isPlaying = true;
          updatePlayButton();
          dom.albumArt.classList.add("playing");
          setStatus("Playing", "success");
        } else {
          // Simple start - stop everything first
          stopImmediate();

          const loaded = await loadPlayers();
          if (!loaded) return;

          // Start all selected stems
          Tone.Transport.position = 0;
          for (const groupId in currentSelection) {
            const take = currentSelection[groupId];
            const player = players[take.id];
            if (player && player.loaded) {
              player.sync().start(0);
            }
          }

          Tone.Transport.start();
          isPlaying = true;
          updatePlayButton();
          dom.albumArt.classList.add("playing");
          setStatus("Playing", "success");
        }
      }

      function pause() {
        if (isPlaying) {
          Tone.Transport.pause();
          isPlaying = false;
          updatePlayButton();
          dom.albumArt.classList.remove("playing");
          setStatus("Paused");
        }
      }

      function stop(resetStatus = true) {
        stopImmediate();
        if (resetStatus) setStatus("");
      }

      function togglePlay() {
        if (isPlaying) {
          pause();
        } else {
          play(false);
        }
      }

      // ============================================
      // UI UPDATES
      // ============================================
      function updateUI() {
        // Update context chips
        dom.chipTime.textContent =
          getTimeOfDay().charAt(0).toUpperCase() + getTimeOfDay().slice(1);
        dom.chipWeather.textContent =
          getWeather().charAt(0).toUpperCase() + getWeather().slice(1);
        dom.chipModeText.textContent = currentMode?.label || "Default";

        // Update stems grid
        dom.stemsGrid.innerHTML = "";

        const selectedCount = Object.keys(currentSelection).length;

        if (selectedCount === 0) {
          // Show empty state
          const emptyCard = document.createElement("div");
          emptyCard.className = "stem-card";
          emptyCard.style.gridColumn = "1 / -1";
          emptyCard.style.textAlign = "center";
          emptyCard.style.color = "var(--muted)";
          emptyCard.innerHTML = `
      <div class="stem-role" style="color: var(--muted);">No stems loaded</div>
      <div class="stem-take">Select a track with uploaded stems</div>
    `;
          dom.stemsGrid.appendChild(emptyCard);
          return;
        }

        for (const group of stemGroups) {
          const take = currentSelection[group.id];
          if (!take) continue;

          const card = document.createElement("div");
          card.className =
            "stem-card" + (group.category === "snack" ? " surprise" : "");

          // Show file name or take id
          const displayName = take.file || take.id;
          const shortName =
            displayName.length > 20
              ? displayName.substring(0, 17) + "..."
              : displayName;

          card.innerHTML = `
      <div class="stem-role">${group.role}</div>
      <div class="stem-take" title="${displayName}">${shortName}</div>
    `;
          dom.stemsGrid.appendChild(card);
        }
      }

      function updatePlayButton() {
        dom.iconPlay.style.display = isPlaying ? "none" : "block";
        dom.iconPause.style.display = isPlaying ? "block" : "none";
        dom.btnPlay.classList.toggle("playing", isPlaying);
        dom.btnPlay.title = isPlaying ? "Pause" : "Play";
      }

      // Progress update loop
      function updateProgress() {
        if (isPlaying && Tone.Transport.state === "started") {
          const currentTime = Tone.Transport.seconds;
          const progress = (currentTime / trackDuration) * 100;
          dom.progressFill.style.width = `${Math.min(progress, 100)}%`;
          dom.timeCurrent.textContent = formatTime(currentTime);

          // Auto-stop at end
          if (currentTime >= trackDuration) {
            stop();
          }
        }
        requestAnimationFrame(updateProgress);
      }

      // ============================================
      // EVENT LISTENERS
      // ============================================
      dom.btnPlay.addEventListener("click", togglePlay);
      dom.btnPrev.addEventListener("click", () => {
        stop();
        buildSelection();
      });
      dom.btnNext.addEventListener("click", () => {
        stop();
        buildSelection();
      });
      dom.btnRegenerate.addEventListener("click", () => {
        stop();
        buildSelection();
        setStatus("Regenerated selection", "success");
      });

      document.getElementById("btn-refresh").addEventListener("click", () => {
        clearAudioCache();
        stop();
        buildSelection();
        setStatus("Cache cleared, audio refreshed", "success");
      });

      // Save mix functionality
      document.getElementById("btn-save-mix").addEventListener("click", () => {
        document.getElementById("save-dialog").style.display = "block";
        const input = document.getElementById("mix-name-input");
        input.value = "";
        input.focus();
      });

      document
        .getElementById("btn-cancel-save")
        .addEventListener("click", () => {
          document.getElementById("save-dialog").style.display = "none";
        });

      document
        .getElementById("btn-confirm-save")
        .addEventListener("click", () => {
          const name = document.getElementById("mix-name-input").value.trim();
          createSavedMix(name);
          document.getElementById("save-dialog").style.display = "none";
          setStatus("Mix saved!", "success");
        });

      document
        .getElementById("mix-name-input")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter") {
            document.getElementById("btn-confirm-save").click();
          }
        });

      dom.selectWeather.addEventListener("change", (e) => {
        currentWeatherOverride = e.target.value;
        stop();
        buildSelection();
      });

      dom.selectTime.addEventListener("change", (e) => {
        currentTimeOverride = e.target.value;
        stop();
        buildSelection();
      });

      // Mode selector
      dom.modeBtns.forEach((btn) => {
        btn.addEventListener("click", () => {
          dom.modeBtns.forEach((b) => b.classList.remove("active"));
          btn.classList.add("active");
          currentPlaybackMode = btn.dataset.mode;
          stop();
          buildSelection();
        });
      });

      // Instrumental toggle
      document
        .getElementById("btn-instrumental")
        .addEventListener("click", toggleInstrumental);

      function toggleInstrumental() {
        instrumentalMode = !instrumentalMode;
        const btn = document.getElementById("btn-instrumental");
        btn.classList.toggle("active", instrumentalMode);
        btn.title = instrumentalMode
          ? "Instrumental ON (vocals muted)"
          : "Toggle Instrumental (mute vocals)";

        // Mute/unmute VOX stems in real-time
        applyInstrumentalMode();

        const status = instrumentalMode
          ? "Instrumental mode ON"
          : "Vocals restored";
        setStatus(status, "success");
      }

      function applyInstrumentalMode() {
        // Find VOX stem groups and mute/unmute their gain nodes
        for (const groupId in voxGainNodes) {
          const gainNode = voxGainNodes[groupId];
          if (gainNode) {
            gainNode.gain.rampTo(instrumentalMode ? 0 : 1, 0.3);
          }
        }
      }

      // Calm mode toggle
      document
        .getElementById("btn-calm")
        .addEventListener("click", toggleCalmMode);

      function toggleCalmMode() {
        calmMode = !calmMode;
        const btn = document.getElementById("btn-calm");
        btn.classList.toggle("active", calmMode);
        btn.title = calmMode
          ? "Calm Mode ON (rhythmic stems muted)"
          : "Toggle Calm Mode (mute rhythmic stems)";

        // Mute/unmute rhythmic stems in real-time
        applyCalmMode();

        const status = calmMode ? "Calm mode ON" : "Full energy restored";
        setStatus(status, "success");
      }

      function applyCalmMode() {
        // Find rhythmic stem groups and mute/unmute their gain nodes
        for (const groupId in rhythmicGainNodes) {
          const gainNode = rhythmicGainNodes[groupId];
          if (gainNode) {
            gainNode.gain.rampTo(calmMode ? 0 : 1, 0.3);
          }
        }
      }

      // Progress bar click to seek
      dom.progressBar.addEventListener("click", (e) => {
        const rect = dom.progressBar.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const seekTime = percent * trackDuration;
        Tone.Transport.seconds = seekTime;
        dom.timeCurrent.textContent = formatTime(seekTime);
      });

      // ============================================
      // FLOATING PARTICLES
      // ============================================
      function createParticles() {
        const container = document.getElementById("particles");
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement("div");
          particle.className = "particle";
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.top = `${Math.random() * 100}%`;
          particle.style.animationDelay = `${Math.random() * 20}s`;
          particle.style.animationDuration = `${15 + Math.random() * 10}s`;
          container.appendChild(particle);
        }
      }

      // ============================================
      // INITIALIZATION
      // ============================================

      // Check for track ID in URL parameters
      function getUrlTrackId() {
        const params = new URLSearchParams(window.location.search);
        return params.get("track");
      }

      // Check if coming from admin (keep full UI visible)
      function isFromAdmin() {
        const params = new URLSearchParams(window.location.search);
        return params.get("from") === "admin";
      }

      // Check if we're in "shared" mode (direct link to a track, not from admin)
      function isSharedMode() {
        return !!getUrlTrackId() && !isFromAdmin();
      }

      async function init() {
        createParticles();
        loadSavedMixes();
        renderSavedMixes();

        // Check if we have a track ID in the URL
        const urlTrackId = getUrlTrackId();

        if (urlTrackId) {
          // Only hide UI in true shared mode (not when coming from admin)
          if (isSharedMode()) {
            const adminTab = document.querySelector(
              '.nav-tab[href="admin.html"]'
            );
            if (adminTab) {
              adminTab.style.display = "none";
            }
            const trackToggle = document.getElementById("track-toggle");
            if (trackToggle) {
              trackToggle.style.display = "none";
            }
          }

          // Load the specific track
          await loadAvailableTracks();

          // Auto-select the track from URL
          const trackExists = availableTracks.find((t) => t.id === urlTrackId);
          if (trackExists) {
            await selectTrack(urlTrackId);
          } else {
            setStatus("Track not found", "error");
            buildSelection();
          }
        } else {
          // Normal mode: load tracks list
          await loadAvailableTracks();
          buildSelection();
        }

        updateProgress();
        dom.timeTotal.textContent = formatTime(trackDuration);

        if (!urlTrackId) {
          setStatus("Select stems and press play");
        }
      }

      init();
    </script>
  </body>
</html>
