<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Living Piece â€” Playlist</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg: #0a0a0a;
        --bg-card: #111111;
        --bg-card-hover: #161616;
        --bg-input: #1a1a1a;
        --border: rgba(255, 255, 255, 0.08);
        --border-hover: rgba(255, 255, 255, 0.15);
        --text: #f5f5f5;
        --text-soft: #a3a3a3;
        --text-muted: #666666;
        --accent: #0ea5e9;
        --accent-hover: #38bdf8;
        --success: #22c55e;
        --warning: #f59e0b;
        --danger: #ef4444;
        --purple: #a855f7;
        --radius: 8px;
        --radius-lg: 12px;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: var(--bg);
        color: var(--text);
        line-height: 1.5;
        min-height: 100vh;
      }

      /* Navigation */
      .nav-header {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        z-index: 100;
        padding: 10px 24px;
        background: rgba(10, 10, 10, 0.9);
        backdrop-filter: blur(20px);
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: center;
      }

      .nav-tabs {
        display: flex;
        gap: 4px;
        background: rgba(255, 255, 255, 0.05);
        padding: 4px;
        border-radius: 10px;
      }

      .nav-tab {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 8px 16px;
        border-radius: 8px;
        text-decoration: none;
        color: var(--text-soft);
        font-size: 13px;
        font-weight: 500;
        transition: all 0.2s ease;
      }

      .nav-tab:hover {
        color: var(--text);
        background: rgba(255, 255, 255, 0.05);
      }
      .nav-tab.active {
        background: var(--accent);
        color: white;
      }
      .nav-tab svg {
        width: 16px;
        height: 16px;
      }

      /* Main Layout */
      .main-container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 80px 24px 24px;
        min-height: 100vh;
      }

      .playlist-layout {
        display: grid;
        grid-template-columns: 280px 1fr;
        gap: 24px;
        min-height: calc(100vh - 104px);
      }

      @media (max-width: 900px) {
        .playlist-layout {
          grid-template-columns: 1fr;
        }
        .sidebar {
          max-height: 300px;
        }
      }

      /* Sidebar */
      .sidebar {
        display: flex;
        flex-direction: column;
        gap: 16px;
        max-height: calc(100vh - 104px);
        position: sticky;
        top: 80px;
      }

      .sidebar-section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        overflow: hidden;
        display: flex;
        flex-direction: column;
      }

      .sidebar-section.releases {
        flex: 1;
        min-height: 150px;
      }

      .sidebar-header {
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
      }

      .sidebar-title {
        font-size: 11px;
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        color: var(--text-muted);
        margin-bottom: 4px;
      }

      .sidebar-helper {
        font-size: 11px;
        color: var(--text-muted);
      }

      .sidebar-list {
        flex: 1;
        overflow-y: auto;
        padding: 8px;
      }

      .sidebar-item {
        padding: 10px 12px;
        border-radius: var(--radius);
        cursor: pointer;
        transition: all 0.15s ease;
        margin-bottom: 4px;
        border: 1px solid transparent;
      }

      .sidebar-item:hover {
        background: var(--bg-card-hover);
        border-color: var(--border);
      }
      .sidebar-item.active {
        background: rgba(14, 165, 233, 0.15);
        border-color: rgba(14, 165, 233, 0.3);
      }

      .sidebar-item-title {
        font-size: 13px;
        font-weight: 500;
        color: var(--text);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .sidebar-item.active .sidebar-item-title {
        color: var(--accent);
      }

      .sidebar-item-meta {
        font-size: 11px;
        color: var(--text-muted);
        margin-top: 2px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .type-badge {
        padding: 2px 6px;
        border-radius: 4px;
        font-size: 9px;
        font-weight: 600;
        text-transform: uppercase;
      }

      .type-badge.album {
        background: rgba(14, 165, 233, 0.2);
        color: var(--accent);
      }
      .type-badge.ep {
        background: rgba(168, 85, 247, 0.2);
        color: var(--purple);
      }
      .type-badge.single {
        background: rgba(34, 197, 94, 0.2);
        color: var(--success);
      }

      /* Main Content */
      .main-content {
        display: flex;
        flex-direction: column;
        gap: 20px;
      }

      /* Playback Mode Selector */
      .mode-bar {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 16px;
        flex-wrap: wrap;
      }

      .mode-label {
        font-size: 12px;
        color: var(--text-muted);
        font-weight: 500;
      }

      .mode-toggle {
        display: flex;
        gap: 4px;
        background: var(--bg-input);
        padding: 4px;
        border-radius: var(--radius);
      }

      .mode-btn {
        padding: 8px 14px;
        border: none;
        background: transparent;
        color: var(--text-soft);
        font-size: 12px;
        font-weight: 500;
        border-radius: 6px;
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .mode-btn:hover {
        color: var(--text);
        background: rgba(255, 255, 255, 0.05);
      }
      .mode-btn.active {
        background: var(--accent);
        color: white;
      }

      /* Now Playing Card */
      .now-playing {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        padding: 24px;
      }

      .now-playing-header {
        display: flex;
        align-items: center;
        gap: 20px;
        margin-bottom: 20px;
      }

      .album-art {
        width: 120px;
        height: 120px;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        border-radius: var(--radius);
        display: flex;
        align-items: center;
        justify-content: center;
        flex-shrink: 0;
        position: relative;
        overflow: hidden;
      }

      .album-art svg.placeholder {
        width: 48px;
        height: 48px;
        color: var(--text-muted);
      }
      .album-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }
      .album-art.playing img {
        animation: art-pulse 3s ease-in-out infinite;
      }

      @keyframes art-pulse {
        0%,
        100% {
          filter: brightness(1);
        }
        50% {
          filter: brightness(1.15);
        }
      }

      .track-info {
        flex: 1;
        min-width: 0;
      }
      .track-title {
        font-size: 20px;
        font-weight: 600;
        margin-bottom: 4px;
      }
      .track-artist {
        font-size: 14px;
        color: var(--text-soft);
        margin-bottom: 8px;
      }
      .track-release {
        font-size: 12px;
        color: var(--text-muted);
      }

      /* Transport Controls */
      .transport {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 16px;
        margin-bottom: 20px;
      }

      .transport-btn {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        border: 1px solid var(--border);
        background: var(--bg-input);
        color: var(--text);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
      }

      .transport-btn:hover {
        background: var(--bg-card-hover);
        border-color: var(--border-hover);
      }
      .transport-btn svg {
        width: 18px;
        height: 18px;
      }

      .transport-btn.play {
        width: 56px;
        height: 56px;
        background: var(--accent);
        border-color: var(--accent);
      }

      .transport-btn.play:hover {
        background: var(--accent-hover);
      }
      .transport-btn.play svg {
        width: 24px;
        height: 24px;
      }

      /* Progress Bar */
      .progress-container {
        margin-bottom: 16px;
      }

      .progress-bar {
        height: 6px;
        background: var(--bg-input);
        border-radius: 3px;
        cursor: pointer;
        overflow: hidden;
        margin-bottom: 8px;
      }

      .progress-fill {
        height: 100%;
        background: var(--accent);
        border-radius: 3px;
        width: 0%;
        transition: width 0.1s linear;
      }

      .progress-times {
        display: flex;
        justify-content: space-between;
        font-size: 11px;
        color: var(--text-muted);
      }

      /* Status */
      .status-bar {
        text-align: center;
        font-size: 12px;
        color: var(--text-muted);
        padding: 8px;
        background: var(--bg-input);
        border-radius: var(--radius);
      }

      .status-bar.success {
        color: var(--success);
      }
      .status-bar.error {
        color: var(--danger);
      }

      /* Transport spacer */
      .transport-spacer {
        flex: 1;
      }

      /* Settings dropdown */
      .settings-container {
        position: relative;
      }

      .settings-dropdown {
        display: none;
        position: absolute;
        bottom: 100%;
        right: 0;
        margin-bottom: 8px;
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius);
        padding: 12px;
        min-width: 180px;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        z-index: 100;
      }

      .settings-dropdown.open {
        display: block;
      }

      .settings-group {
        margin-bottom: 12px;
      }

      .settings-group:last-child {
        margin-bottom: 0;
      }

      .settings-label {
        font-size: 10px;
        color: var(--text-muted);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 6px;
      }

      .settings-options {
        display: flex;
        gap: 4px;
      }

      .settings-chip {
        padding: 4px 10px;
        font-size: 11px;
        border-radius: var(--radius);
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .settings-chip:hover {
        border-color: var(--border-hover);
        color: var(--text-soft);
        background: var(--bg-card-hover);
      }

      .settings-chip.active {
        background: var(--accent);
        border-color: var(--accent);
        color: white;
      }

      #btn-settings.has-override {
        color: var(--accent);
      }

      /* Queue */
      .queue-section {
        background: var(--bg-card);
        border: 1px solid var(--border);
        border-radius: var(--radius-lg);
        overflow: hidden;
      }

      .queue-header {
        padding: 14px 16px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .queue-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--text);
      }

      .queue-actions {
        display: flex;
        gap: 8px;
      }

      .queue-btn {
        padding: 6px 10px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text-soft);
        font-size: 11px;
        border-radius: var(--radius);
        cursor: pointer;
        transition: all 0.15s ease;
      }

      .queue-btn:hover {
        background: var(--bg-card-hover);
        color: var(--text);
      }

      .queue-list {
        max-height: 300px;
        overflow-y: auto;
      }

      .queue-item {
        padding: 10px 16px;
        display: flex;
        align-items: center;
        gap: 12px;
        border-bottom: 1px solid var(--border);
        transition: background 0.15s ease;
        cursor: pointer;
      }

      .queue-item:last-child {
        border-bottom: none;
      }
      .queue-item:hover {
        background: var(--bg-card-hover);
      }
      .queue-item.current {
        background: rgba(14, 165, 233, 0.1);
      }

      .queue-art {
        width: 40px;
        height: 40px;
        border-radius: 4px;
        overflow: hidden;
        flex-shrink: 0;
        background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .queue-art svg {
        width: 20px;
        height: 20px;
        color: var(--text-muted);
      }
      .queue-art img {
        width: 100%;
        height: 100%;
        object-fit: cover;
      }

      .queue-number {
        width: 20px;
        font-size: 11px;
        color: var(--text-muted);
        text-align: center;
        flex-shrink: 0;
      }

      .queue-item.current .queue-number {
        color: var(--accent);
        font-weight: 600;
      }

      .queue-item-info {
        flex: 1;
        min-width: 0;
      }

      .queue-item-title {
        font-size: 13px;
        font-weight: 500;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .queue-item-meta {
        font-size: 11px;
        color: var(--text-muted);
      }

      .queue-item-remove {
        width: 28px;
        height: 28px;
        border: none;
        background: transparent;
        color: var(--text-muted);
        cursor: pointer;
        border-radius: var(--radius);
        display: flex;
        align-items: center;
        justify-content: center;
        opacity: 0;
        transition: all 0.15s ease;
      }

      .queue-item:hover .queue-item-remove {
        opacity: 1;
      }
      .queue-item-remove:hover {
        background: var(--danger);
        color: white;
      }
      .queue-item-remove svg {
        width: 14px;
        height: 14px;
      }

      .queue-empty {
        padding: 32px;
        text-align: center;
        color: var(--text-muted);
        font-size: 13px;
      }

      /* Shuffle/Repeat indicators */
      .playback-options {
        display: flex;
        gap: 8px;
      }

      .option-btn {
        width: 32px;
        height: 32px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text-muted);
        border-radius: var(--radius);
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.15s ease;
      }

      .option-btn:hover {
        background: var(--bg-card-hover);
        color: var(--text);
      }
      .option-btn.active {
        background: rgba(14, 165, 233, 0.2);
        color: var(--accent);
        border-color: var(--accent);
      }
      .option-btn svg {
        width: 16px;
        height: 16px;
      }

      /* Instrumental button - pink when active */
      #btn-instrumental.active {
        background: rgba(236, 72, 153, 0.2);
        color: #ec4899;
        border-color: #ec4899;
      }
      #btn-instrumental.active svg {
        opacity: 0.6;
      }

      /* Calm button - blue when active */
      #btn-calm.active {
        background: rgba(147, 197, 253, 0.2);
        color: #93c5fd;
        border-color: #93c5fd;
      }
      #btn-calm.active svg {
        opacity: 0.7;
      }
    </style>
  </head>
  <body>
    <!-- Navigation -->
    <nav class="nav-header">
      <div class="nav-tabs">
        <a href="living-piece-player.html" class="nav-tab">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M9 18V5l12-2v13" />
            <circle cx="6" cy="18" r="3" />
            <circle cx="18" cy="16" r="3" />
          </svg>
          Listening
        </a>
        <a href="#" class="nav-tab active">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <path d="M21 15V6" />
            <path d="M18.5 18a2.5 2.5 0 100-5 2.5 2.5 0 000 5z" />
            <path d="M12 12H3" />
            <path d="M16 6H3" />
            <path d="M12 18H3" />
          </svg>
          Playlist
        </a>
        <a href="admin.html" class="nav-tab">
          <svg
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="2"
          >
            <circle cx="12" cy="12" r="3" />
            <path
              d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"
            />
          </svg>
          Admin
        </a>
      </div>
    </nav>

    <!-- Main Container -->
    <div class="main-container">
      <div class="playlist-layout">
        <!-- Sidebar: Releases & All Tracks -->
        <div class="sidebar">
          <aside class="sidebar-section releases" style="flex: 1">
            <div class="sidebar-header">
              <div class="sidebar-title">Library</div>
              <div class="sidebar-helper">Click to queue tracks</div>
            </div>
            <div class="sidebar-list" id="releases-list">
              <!-- Populated by JS -->
            </div>
          </aside>

          <aside class="sidebar-section" style="max-height: 200px">
            <div class="sidebar-header">
              <div class="sidebar-title">Saved Mixes</div>
              <div class="sidebar-helper">Your favorite configurations</div>
            </div>
            <div class="sidebar-list" id="saved-mixes-list">
              <!-- Populated by JS -->
            </div>
          </aside>
        </div>

        <!-- Main Content -->
        <div class="main-content">
          <!-- Playback Mode -->
          <div class="mode-bar">
            <span class="mode-label">Playback Mode</span>
            <div class="mode-toggle">
              <button class="mode-btn active" data-mode="fixed">Fixed</button>
              <button class="mode-btn" data-mode="dynamic">Dynamic</button>
              <button class="mode-btn" data-mode="dynamic_plus">
                + Surprises
              </button>
            </div>
            <div class="playback-options">
              <button
                class="option-btn"
                id="btn-instrumental"
                title="Instrumental (mute vocals)"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M12 1a3 3 0 00-3 3v8a3 3 0 006 0V4a3 3 0 00-3-3z" />
                  <path d="M19 10v2a7 7 0 01-14 0v-2" />
                  <line x1="12" y1="19" x2="12" y2="23" />
                  <line x1="8" y1="23" x2="16" y2="23" />
                </svg>
              </button>
              <button
                class="option-btn"
                id="btn-calm"
                title="Calm Mode (mute rhythmic stems)"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
                </svg>
              </button>
              <button class="option-btn" id="btn-shuffle" title="Shuffle">
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <polyline points="16,3 21,3 21,8" />
                  <line x1="4" y1="20" x2="21" y2="3" />
                  <polyline points="21,16 21,21 16,21" />
                  <line x1="15" y1="15" x2="21" y2="21" />
                  <line x1="4" y1="4" x2="9" y2="9" />
                </svg>
              </button>
              <button class="option-btn" id="btn-repeat" title="Repeat">
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <polyline points="17,1 21,5 17,9" />
                  <path d="M3 11V9a4 4 0 014-4h14" />
                  <polyline points="7,23 3,19 7,15" />
                  <path d="M21 13v2a4 4 0 01-4 4H3" />
                </svg>
              </button>
            </div>
          </div>

          <!-- Now Playing -->
          <div class="now-playing">
            <div class="now-playing-header">
              <div class="album-art" id="album-art">
                <svg
                  class="placeholder"
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="1.5"
                >
                  <path d="M9 18V5l12-2v13" />
                  <circle cx="6" cy="18" r="3" />
                  <circle cx="18" cy="16" r="3" />
                </svg>
              </div>
              <div class="track-info">
                <div class="track-title" id="track-title">
                  No track selected
                </div>
                <div class="track-artist" id="track-artist">
                  Select a release to begin
                </div>
                <div class="track-release" id="track-release"></div>
              </div>
            </div>

            <div class="transport">
              <button class="transport-btn" id="btn-prev" title="Previous">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M6 6h2v12H6V6zm3.5 6l8.5 6V6l-8.5 6z" />
                </svg>
              </button>
              <button class="transport-btn play" id="btn-play" title="Play">
                <svg viewBox="0 0 24 24" fill="currentColor" id="icon-play">
                  <polygon points="5,3 19,12 5,21" />
                </svg>
              </button>
              <button class="transport-btn" id="btn-next" title="Next">
                <svg viewBox="0 0 24 24" fill="currentColor">
                  <path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z" />
                </svg>
              </button>
              <div class="transport-spacer"></div>
              <button
                class="transport-btn"
                id="btn-save-mix"
                title="Save this mix to favorites"
              >
                <svg
                  viewBox="0 0 24 24"
                  fill="none"
                  stroke="currentColor"
                  stroke-width="2"
                >
                  <path d="M19 21l-7-5-7 5V5a2 2 0 012-2h10a2 2 0 012 2z" />
                </svg>
              </button>
              <div class="settings-container">
                <button
                  class="transport-btn"
                  id="btn-settings"
                  title="Playback settings"
                >
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    stroke-width="2"
                  >
                    <circle cx="12" cy="12" r="3" />
                    <path
                      d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 010 2.83 2 2 0 01-2.83 0l-.06-.06a1.65 1.65 0 00-1.82-.33 1.65 1.65 0 00-1 1.51V21a2 2 0 01-2 2 2 2 0 01-2-2v-.09A1.65 1.65 0 009 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0 2 2 0 010-2.83l.06-.06a1.65 1.65 0 00.33-1.82 1.65 1.65 0 00-1.51-1H3a2 2 0 01-2-2 2 2 0 012-2h.09A1.65 1.65 0 004.6 9a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 010-2.83 2 2 0 012.83 0l.06.06a1.65 1.65 0 001.82.33H9a1.65 1.65 0 001-1.51V3a2 2 0 012-2 2 2 0 012 2v.09a1.65 1.65 0 001 1.51 1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0 2 2 0 010 2.83l-.06.06a1.65 1.65 0 00-.33 1.82V9a1.65 1.65 0 001.51 1H21a2 2 0 012 2 2 2 0 01-2 2h-.09a1.65 1.65 0 00-1.51 1z"
                    />
                  </svg>
                </button>
                <div class="settings-dropdown" id="settings-dropdown">
                  <div class="settings-group">
                    <div class="settings-label">Time of Day</div>
                    <div class="settings-options" id="time-options">
                      <button class="settings-chip active" data-time="auto">
                        Auto
                      </button>
                      <button class="settings-chip" data-time="day">Day</button>
                      <button class="settings-chip" data-time="night">
                        Night
                      </button>
                    </div>
                  </div>
                  <div class="settings-group">
                    <div class="settings-label">Weather</div>
                    <div class="settings-options" id="weather-options">
                      <button class="settings-chip active" data-weather="auto">
                        Auto
                      </button>
                      <button class="settings-chip" data-weather="warm">
                        Warm
                      </button>
                      <button class="settings-chip" data-weather="cold">
                        Cold
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="progress-container">
              <div class="progress-bar" id="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
              </div>
              <div class="progress-times">
                <span id="time-current">0:00</span>
                <span id="time-total">0:00</span>
              </div>
            </div>

            <div class="status-bar" id="status-bar">
              Select a release to start listening
            </div>
          </div>

          <!-- Queue -->
          <div class="queue-section">
            <div class="queue-header">
              <span class="queue-title">Up Next</span>
              <div class="queue-actions">
                <button class="queue-btn" id="btn-clear-queue">
                  Clear Queue
                </button>
              </div>
            </div>
            <div class="queue-list" id="queue-list">
              <div class="queue-empty">No tracks in queue</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <script>
      // ============================================
      // SUPABASE SETUP
      // ============================================
      const supabaseUrl = "https://cimngwcwvbspkcqdzqfg.supabase.co";
      const supabaseKey =
        "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNpbW5nd2N3dmJzcGtjcWR6cWZnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjQ1MzA1MDIsImV4cCI6MjA4MDEwNjUwMn0.L9Tvj4mlSjAtiSVMPkaegRF4laZl_E15ALZFdRhSzUg";
      const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

      // ============================================
      // STATE
      // ============================================
      let allReleases = [];
      let allTracks = [];
      let queue = [];
      let currentQueueIndex = -1;
      let currentTrackData = null;
      let playbackMode = "fixed"; // fixed, dynamic, dynamic_plus
      let isPlaying = false;
      let isLoading = false;
      let shuffleEnabled = false;
      let repeatEnabled = false;

      // Audio state
      let players = {};
      let masterGain = null;
      let currentSelection = {};
      let trackDuration = 0;
      let voxGainNodes = {}; // Store gain nodes for VOX stems to mute/unmute

      // Track-specific data
      let stemGroups = [];
      let takes = [];
      let modes = [];
      let usedTakesHistory = {};

      // Mode override state (null = auto)
      let timeOverride = null; // 'day', 'night', or null (auto)
      let weatherOverride = null; // 'warm', 'cold', or null (auto)
      let instrumentalMode = false; // Mutes VOX category stems
      let calmMode = false; // Mutes rhythmic/intense stems
      let rhythmicGainNodes = {}; // Store gain nodes for rhythmic stems

      // Saved mixes (shared with player via localStorage)
      const STORAGE_KEY = "livingPiece_savedMixes";
      let savedMixes = [];

      // ============================================
      // DOM ELEMENTS
      // ============================================
      const dom = {
        releasesList: document.getElementById("releases-list"),
        trackTitle: document.getElementById("track-title"),
        trackArtist: document.getElementById("track-artist"),
        trackRelease: document.getElementById("track-release"),
        albumArt: document.getElementById("album-art"),
        btnPlay: document.getElementById("btn-play"),
        btnPrev: document.getElementById("btn-prev"),
        btnNext: document.getElementById("btn-next"),
        btnShuffle: document.getElementById("btn-shuffle"),
        btnRepeat: document.getElementById("btn-repeat"),
        btnInstrumental: document.getElementById("btn-instrumental"),
        btnCalm: document.getElementById("btn-calm"),
        btnSettings: document.getElementById("btn-settings"),
        settingsDropdown: document.getElementById("settings-dropdown"),
        progressBar: document.getElementById("progress-bar"),
        progressFill: document.getElementById("progress-fill"),
        timeCurrent: document.getElementById("time-current"),
        timeTotal: document.getElementById("time-total"),
        statusBar: document.getElementById("status-bar"),
        queueList: document.getElementById("queue-list"),
        btnClearQueue: document.getElementById("btn-clear-queue"),
        timeOptions: document.getElementById("time-options"),
        weatherOptions: document.getElementById("weather-options"),
      };

      // ============================================
      // UTILITY FUNCTIONS
      // ============================================
      function escapeHtml(text) {
        if (!text) return "";
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      function formatTime(seconds) {
        if (!seconds || isNaN(seconds)) return "0:00";
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins}:${secs.toString().padStart(2, "0")}`;
      }

      function setStatus(message, type = "") {
        dom.statusBar.textContent = message;
        dom.statusBar.className = "status-bar " + type;
      }

      function setLoading(loading) {
        isLoading = loading;
        dom.btnPlay.disabled = loading;
      }

      // ============================================
      // GEOMETRIC ALBUM ART GENERATOR
      // ============================================
      // Get album art HTML - uses cover image if available, otherwise placeholder
      function getAlbumArt(track, size = 120) {
        // Check for track cover first, then release cover
        let coverUrl = track?.cover_image_url;

        if (!coverUrl && track?.release_id) {
          const release = allReleases.find((r) => r.id === track.release_id);
          coverUrl = release?.cover_image_url;
        }

        if (coverUrl) {
          return `<img src="${escapeHtml(coverUrl)}" alt="${escapeHtml(
            track?.title || "Cover"
          )}" style="width: 100%; height: 100%; object-fit: cover;" />`;
        }

        // Default placeholder
        return `<svg class="placeholder" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
    <path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/>
  </svg>`;
      }

      // Small version for queue items
      function getSmallAlbumArt(track) {
        return getAlbumArt(track, 40);
      }

      // ============================================
      // RELEASES & TRACKS LOADING
      // ============================================
      async function loadReleases() {
        const { data, error } = await supabase
          .from("releases")
          .select("*")
          .eq("is_active", true)
          .order("sort_order");

        if (error) {
          console.error("Error loading releases:", error);
          return;
        }

        allReleases = data || [];
        renderReleasesList();
      }

      async function loadAllTracks() {
        const { data, error } = await supabase
          .from("tracks")
          .select("*")
          .eq("is_active", true)
          .order("track_number");

        if (error) {
          console.error("Error loading tracks:", error);
          return;
        }

        allTracks = data || [];
      }

      function renderReleasesList() {
        let html = "";

        // "All Tracks" option at top
        html += `
    <div class="sidebar-item" data-release-id="all" style="border-bottom: 1px solid var(--border); margin-bottom: 8px; padding-bottom: 12px;">
      <div class="sidebar-item-title">All Tracks</div>
      <div class="sidebar-item-meta">
        <span>${allTracks.length} track${
          allTracks.length !== 1 ? "s" : ""
        }</span>
      </div>
    </div>
  `;

        // Releases
        if (allReleases.length > 0) {
          html += allReleases
            .map((release) => {
              const trackCount = allTracks.filter(
                (t) => t.release_id === release.id
              ).length;
              return `
        <div class="sidebar-item" data-release-id="${release.id}">
          <div class="sidebar-item-title">${escapeHtml(release.title)}</div>
          <div class="sidebar-item-meta">
            <span class="type-badge ${release.release_type}">${
                release.release_type
              }</span>
            <span>${trackCount} track${trackCount !== 1 ? "s" : ""}</span>
          </div>
        </div>
      `;
            })
            .join("");
        }

        dom.releasesList.innerHTML = html;

        // Add click handlers
        dom.releasesList.querySelectorAll(".sidebar-item").forEach((item) => {
          item.addEventListener("click", () => {
            const releaseId = item.dataset.releaseId;
            if (releaseId === "all") {
              queueAllTracks();
            } else {
              queueRelease(releaseId);
            }
          });
        });
      }

      function queueAllTracks() {
        if (allTracks.length === 0) {
          setStatus("No tracks available", "error");
          return;
        }

        // Queue all tracks sorted by release, then track number
        queue = allTracks
          .map((track) => {
            const release = allReleases.find((r) => r.id === track.release_id);
            return {
              ...track,
              releaseName: release ? release.title : "Single",
              releaseSort: release ? release.sort_order : 9999,
            };
          })
          .sort((a, b) => {
            if (a.releaseSort !== b.releaseSort)
              return a.releaseSort - b.releaseSort;
            return (a.track_number || 0) - (b.track_number || 0);
          });

        currentQueueIndex = -1;

        // Highlight All Tracks
        dom.releasesList.querySelectorAll(".sidebar-item").forEach((item) => {
          item.classList.toggle("active", item.dataset.releaseId === "all");
        });

        renderQueue();
        setStatus(`Queued all ${queue.length} tracks`);

        // Auto-play first track
        playTrackAtIndex(0);
      }

      // ============================================
      // QUEUE MANAGEMENT
      // ============================================
      function queueRelease(releaseId) {
        const release = allReleases.find((r) => r.id === releaseId);
        if (!release) return;

        // Get tracks for this release
        const releaseTracks = allTracks
          .filter((t) => t.release_id === releaseId)
          .sort((a, b) => (a.track_number || 0) - (b.track_number || 0));

        if (releaseTracks.length === 0) {
          setStatus("No tracks in this release", "error");
          return;
        }

        // Clear queue and add release tracks
        queue = releaseTracks.map((track) => ({
          ...track,
          releaseName: release.title,
        }));

        currentQueueIndex = -1;

        // Highlight selected release
        dom.releasesList.querySelectorAll(".sidebar-item").forEach((item) => {
          item.classList.toggle("active", item.dataset.releaseId === releaseId);
        });

        renderQueue();
        setStatus(`Queued ${queue.length} tracks from "${release.title}"`);

        // Auto-play first track
        playTrackAtIndex(0);
      }

      function renderQueue() {
        if (queue.length === 0) {
          dom.queueList.innerHTML =
            '<div class="queue-empty">No tracks in queue</div>';
          return;
        }

        dom.queueList.innerHTML = queue
          .map(
            (track, index) => `
    <div class="queue-item ${
      index === currentQueueIndex ? "current" : ""
    }" data-index="${index}">
      <div class="queue-art">${getAlbumArt(track, 40)}</div>
      <div class="queue-number">${index + 1}</div>
      <div class="queue-item-info">
        <div class="queue-item-title">${escapeHtml(track.title)}</div>
        <div class="queue-item-meta">${escapeHtml(
          track.releaseName || "Single"
        )}</div>
      </div>
      <button class="queue-item-remove" data-index="${index}" title="Remove">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    </div>
  `
          )
          .join("");

        // Click to play
        dom.queueList.querySelectorAll(".queue-item").forEach((item) => {
          item.addEventListener("click", (e) => {
            if (!e.target.closest(".queue-item-remove")) {
              playTrackAtIndex(parseInt(item.dataset.index));
            }
          });
        });

        // Remove buttons
        dom.queueList.querySelectorAll(".queue-item-remove").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            removeFromQueue(parseInt(btn.dataset.index));
          });
        });
      }

      function removeFromQueue(index) {
        if (index === currentQueueIndex) {
          // If removing current track, stop playback
          stop();
          currentQueueIndex = -1;
        } else if (index < currentQueueIndex) {
          currentQueueIndex--;
        }

        queue.splice(index, 1);
        renderQueue();
      }

      function clearQueue() {
        stop();
        queue = [];
        currentQueueIndex = -1;
        currentTrackData = null;
        renderQueue();
        updateNowPlaying();
        setStatus("Queue cleared");
      }

      // ============================================
      // TRACK LOADING & PLAYBACK
      // ============================================
      async function playTrackAtIndex(index) {
        if (index < 0 || index >= queue.length) return;

        // Stop current playback
        await stop();

        // Clean up old players and reset duration for new track
        Object.values(players).forEach((p) => {
          try {
            p.dispose();
          } catch {}
        });
        players = {};
        voxGainNodes = {};
        rhythmicGainNodes = {};
        trackDuration = 0;
        dom.timeTotal.textContent = "0:00";

        currentQueueIndex = index;
        const track = queue[index];
        currentTrackData = track;

        renderQueue();
        updateNowPlaying();

        // Load track data (modes, stem groups, takes)
        await loadTrackData(track.id);

        // Build selection and play
        buildSelection();
        await play();
      }

      async function loadTrackData(trackId) {
        setLoading(true);
        setStatus("Loading track data...");

        try {
          // Load modes
          const { data: modesData } = await supabase
            .from("modes")
            .select("*")
            .eq("track_id", trackId);

          modes = (modesData || []).map((m) => ({
            id: m.id,
            slug: m.slug,
            label: m.label,
            time: m.time_of_day,
            weather: m.weather_tag,
          }));

          // Load stem groups
          const { data: groupsData } = await supabase
            .from("stem_groups")
            .select("*")
            .eq("track_id", trackId);

          stemGroups = (groupsData || []).map((g) => ({
            id: g.id,
            role: g.role,
            name: g.display_name,
            category: g.category,
            isRequired: g.is_required,
            canSurprise: g.can_be_surprise,
            volume: g.volume_default,
            isRhythmic: g.is_rhythmic || false,
          }));

          // Load takes
          if (stemGroups.length > 0) {
            const groupIds = stemGroups.map((g) => g.id);
            const { data: takesData } = await supabase
              .from("stem_takes")
              .select("*")
              .in("stem_group_id", groupIds)
              .eq("is_enabled", true);

            takes = (takesData || []).map((t) => {
              // Decode URL so Tone.js can re-encode it properly
              let url = t.audio_url || "";
              try {
                url = decodeURIComponent(url);
              } catch (e) {
                // If decode fails, use original
              }
              return {
                id: t.id,
                group: t.stem_group_id,
                url: url,
                mode: t.mode_id,
                weight: t.weight || 1,
                isDefault: t.is_default,
              };
            });
          } else {
            takes = [];
          }

          // Reset history for new track
          usedTakesHistory = {};

          // Reset mode overrides to auto for new track
          timeOverride = null;
          weatherOverride = null;

          setStatus("Track loaded", "success");
        } catch (err) {
          console.error("Error loading track data:", err);
          setStatus("Error loading track", "error");
        }

        setLoading(false);
      }

      function updateNowPlaying() {
        if (!currentTrackData) {
          dom.trackTitle.textContent = "No track selected";
          dom.trackArtist.textContent = "Select a release to begin";
          dom.trackRelease.textContent = "";
          dom.albumArt.innerHTML = `<svg class="placeholder" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
      <path d="M9 18V5l12-2v13"/><circle cx="6" cy="18" r="3"/><circle cx="18" cy="16" r="3"/>
    </svg>`;
          return;
        }

        dom.trackTitle.textContent = currentTrackData.title;
        dom.trackArtist.textContent =
          currentTrackData.description || "Adaptive Composition";
        dom.trackRelease.textContent = currentTrackData.releaseName || "";
        dom.albumArt.innerHTML = getAlbumArt(currentTrackData, 120);

        // Update settings button state
        updateSettingsButtonState();
      }

      function updateSettingsButtonState() {
        // Highlight settings button if any override is active
        const hasOverride = timeOverride !== null || weatherOverride !== null;
        dom.btnSettings.classList.toggle("has-override", hasOverride);

        // Update chip states
        dom.timeOptions.querySelectorAll(".settings-chip").forEach((chip) => {
          const value = chip.dataset.time;
          const isActive =
            (value === "auto" && timeOverride === null) ||
            value === timeOverride;
          chip.classList.toggle("active", isActive);
        });

        dom.weatherOptions
          .querySelectorAll(".settings-chip")
          .forEach((chip) => {
            const value = chip.dataset.weather;
            const isActive =
              (value === "auto" && weatherOverride === null) ||
              value === weatherOverride;
            chip.classList.toggle("active", isActive);
          });
      }

      function setupSettingsDropdown() {
        // Toggle dropdown
        dom.btnSettings.addEventListener("click", (e) => {
          e.stopPropagation();
          dom.settingsDropdown.classList.toggle("open");
        });

        // Close on outside click
        document.addEventListener("click", (e) => {
          if (
            !dom.settingsDropdown.contains(e.target) &&
            e.target !== dom.btnSettings
          ) {
            dom.settingsDropdown.classList.remove("open");
          }
        });

        // Time option clicks
        dom.timeOptions.querySelectorAll(".settings-chip").forEach((chip) => {
          chip.addEventListener("click", () => {
            const value = chip.dataset.time;
            timeOverride = value === "auto" ? null : value;
            updateSettingsButtonState();
            if (isPlaying) {
              rebuildAndContinue();
            }
          });
        });

        // Weather option clicks
        dom.weatherOptions
          .querySelectorAll(".settings-chip")
          .forEach((chip) => {
            chip.addEventListener("click", () => {
              const value = chip.dataset.weather;
              weatherOverride = value === "auto" ? null : value;
              updateSettingsButtonState();
              if (isPlaying) {
                rebuildAndContinue();
              }
            });
          });
      }

      async function rebuildAndContinue() {
        // Store current position
        const currentPosition = Tone.Transport.seconds;

        // Stop without resetting
        Tone.Transport.pause();

        // Rebuild selection with new mode settings
        buildSelection();

        // Load any new players needed
        await loadPlayers();

        // Resume from same position
        Tone.Transport.seconds = currentPosition;
        Tone.Transport.start();

        const stemCount = Object.keys(currentSelection).length;
        setStatus(`Playing ${stemCount} stems`, "success");
      }

      // ============================================
      // STEM SELECTION (from player logic)
      // ============================================
      function getEffectiveTimeWeather() {
        // Determine current time/weather (auto or override)
        let time = timeOverride;
        let weather = weatherOverride;

        // Auto-detect time based on actual time of day
        if (!time) {
          const hour = new Date().getHours();
          time = hour >= 6 && hour < 18 ? "day" : "night";
        }

        // Auto-detect weather (default to warm for now, could use weather API)
        if (!weather) {
          weather = "warm";
        }

        return { time, weather };
      }

      function filterTakesByMode(takesToFilter) {
        const { time, weather } = getEffectiveTimeWeather();

        // Find matching modes
        const matchingModes = modes.filter((m) => {
          const modeTime =
            m.time === "morning" || m.time === "afternoon"
              ? "day"
              : m.time === "evening" || m.time === "night"
              ? "night"
              : m.time;
          const modeWeather =
            m.weather === "sunny" || m.weather === "warm"
              ? "warm"
              : m.weather === "rain" || m.weather === "cold"
              ? "cold"
              : m.weather;

          const timeMatch = !m.time || modeTime === time;
          const weatherMatch = !m.weather || modeWeather === weather;
          return timeMatch && weatherMatch;
        });

        if (matchingModes.length === 0) {
          // No modes match, return all takes
          return takesToFilter;
        }

        const matchingModeIds = matchingModes.map((m) => m.id);

        // Filter takes that belong to matching modes, or have no mode (universal)
        const filtered = takesToFilter.filter(
          (t) => !t.mode || matchingModeIds.includes(t.mode)
        );

        // If filtering removes all takes, return original
        return filtered.length > 0 ? filtered : takesToFilter;
      }

      function buildSelection() {
        currentSelection = {};

        if (takes.length === 0) {
          console.log("No takes available");
          return;
        }

        const shouldAlternate =
          playbackMode === "dynamic" || playbackMode === "dynamic_plus";

        // In surprises mode, occasionally trigger instrumental (15% chance)
        let surpriseInstrumental = false;
        if (
          playbackMode === "dynamic_plus" &&
          !instrumentalMode &&
          Math.random() < 0.15
        ) {
          surpriseInstrumental = true;
        }

        for (const group of stemGroups) {
          // Skip snack layers unless dynamic_plus
          if (group.category === "snack") {
            if (playbackMode === "dynamic_plus" && Math.random() > 0.5) {
              const snackTakes = filterTakesByMode(
                takes.filter((t) => t.group === group.id)
              );
              if (snackTakes.length) {
                currentSelection[group.id] = selectTakeWithAlternation(
                  snackTakes,
                  group.id,
                  shouldAlternate
                );
              }
            }
            continue;
          }

          // Skip VOX if instrumental mode or surprise instrumental
          if (
            group.category === "vox" &&
            (instrumentalMode || surpriseInstrumental)
          ) {
            continue;
          }

          // Filter takes by mode (time/weather)
          const groupTakes = filterTakesByMode(
            takes.filter((t) => t.group === group.id)
          );
          if (groupTakes.length === 0) continue;

          currentSelection[group.id] = selectTakeWithAlternation(
            groupTakes,
            group.id,
            shouldAlternate
          );
        }

        // Update history
        for (const groupId in currentSelection) {
          const takeId = currentSelection[groupId].id;
          if (!usedTakesHistory[groupId]) usedTakesHistory[groupId] = [];
          usedTakesHistory[groupId].push(takeId);
        }

        console.log(
          "Selection built:",
          Object.keys(currentSelection).length,
          "stems"
        );
      }

      function selectTakeWithAlternation(validTakes, groupId, shouldAlternate) {
        if (validTakes.length === 1 || !shouldAlternate) {
          return weightedRandomTake(validTakes);
        }

        const history = usedTakesHistory[groupId] || [];
        let availableTakes = validTakes.filter((t) => !history.includes(t.id));

        if (availableTakes.length === 0) {
          const lastPlayed = history[history.length - 1];
          usedTakesHistory[groupId] = lastPlayed ? [lastPlayed] : [];
          availableTakes = validTakes.filter((t) => t.id !== lastPlayed);
          if (availableTakes.length === 0) availableTakes = validTakes;
        }

        return weightedRandomTake(availableTakes);
      }

      function weightedRandomTake(takes) {
        if (takes.length === 0) return null;
        if (takes.length === 1) return takes[0];

        const totalWeight = takes.reduce((sum, t) => sum + (t.weight || 1), 0);
        let random = Math.random() * totalWeight;

        for (const take of takes) {
          random -= take.weight || 1;
          if (random <= 0) return take;
        }

        return takes[0];
      }

      // ============================================
      // AUDIO ENGINE
      // ============================================
      function initAudio() {
        if (!masterGain) {
          masterGain = new Tone.Gain(1).toDestination();
        }
      }

      async function loadPlayers() {
        setLoading(true);
        setStatus("Loading audio...");

        try {
          await Tone.start();
          initAudio();

          const selectedTakes = Object.values(currentSelection);
          const loadPromises = [];

          for (const take of selectedTakes) {
            if (!players[take.id] && take.url) {
              // Find the stem group to get volume and category
              const group = stemGroups.find((g) => g.id === take.group);
              const volume = group?.volume !== undefined ? group.volume : 1;
              const isVox = group?.category === "vox";
              const isRhythmic = group?.isRhythmic || false;

              // Load audio using fetch to bypass Tone.js URL encoding issues
              const loadPromise = (async () => {
                try {
                  const response = await fetch(take.url);
                  if (!response.ok) throw new Error(`HTTP ${response.status}`);
                  const arrayBuffer = await response.arrayBuffer();
                  const audioBuffer = await Tone.context.decodeAudioData(
                    arrayBuffer
                  );

                  const player = new Tone.Player(audioBuffer);

                  // Apply volume through a gain node
                  const volumeGain = new Tone.Gain(volume).connect(masterGain);
                  let outputNode = volumeGain;

                  // Rhythmic stems get their own gain node (for calm mode)
                  if (isRhythmic) {
                    const rhythmicGain = new Tone.Gain(
                      calmMode ? 0 : 1
                    ).connect(outputNode);
                    rhythmicGainNodes[take.group] = rhythmicGain;
                    outputNode = rhythmicGain;
                  }

                  // For VOX stems, add an extra gain node for muting
                  if (isVox) {
                    const voxGain = new Tone.Gain(
                      instrumentalMode ? 0 : 1
                    ).connect(outputNode);
                    voxGainNodes[take.group] = voxGain;
                    outputNode = voxGain;
                  }

                  player.connect(outputNode);

                  players[take.id] = player;
                  console.log("Loaded:", take.url);
                } catch (err) {
                  console.error("Failed to load:", take.url, err);
                }
              })();

              loadPromises.push(loadPromise);
            }
          }

          if (loadPromises.length > 0) {
            await Promise.all(loadPromises);
          }

          // Get duration from loaded players
          for (const takeId in players) {
            const player = players[takeId];
            if (player?.buffer?.duration > 0) {
              trackDuration = player.buffer.duration;
              dom.timeTotal.textContent = formatTime(trackDuration);
              break;
            }
          }

          setLoading(false);
          return true;
        } catch (err) {
          console.error("Audio loading error:", err);
          setLoading(false);
          setStatus("Failed to load audio", "error");
          return false;
        }
      }

      async function play() {
        if (isLoading) return;

        const loaded = await loadPlayers();
        if (!loaded) return;

        // Stop any current playback
        Tone.Transport.stop();
        Tone.Transport.position = 0;

        // Schedule all players
        const selectedTakes = Object.values(currentSelection);
        let playingCount = 0;

        for (const take of selectedTakes) {
          const player = players[take.id];
          if (player && player.buffer && player.buffer.duration > 0) {
            try {
              player.unsync(); // Ensure clean state
              player.sync().start(0);
              playingCount++;
              console.log("Playing stem:", take.id, "from group:", take.group);
            } catch (err) {
              console.error("Error starting player:", take.id, err);
            }
          } else {
            console.warn(
              "Player not ready:",
              take.id,
              "loaded:",
              player?.loaded,
              "buffer:",
              !!player?.buffer
            );
          }
        }

        console.log(`Started ${playingCount} of ${selectedTakes.length} stems`);

        // Schedule track end
        Tone.Transport.scheduleOnce(() => {
          onTrackEnd();
        }, trackDuration);

        Tone.Transport.start();
        isPlaying = true;
        updatePlayButton();
        dom.albumArt.classList.add("playing");

        setStatus(`Playing ${playingCount} stems`, "success");
      }

      async function stop() {
        Tone.Transport.stop();
        Tone.Transport.position = 0;
        Tone.Transport.cancel();

        Object.values(players).forEach((p) => {
          try {
            p.stop();
            p.unsync();
          } catch {}
        });

        isPlaying = false;
        updatePlayButton();
        dom.albumArt.classList.remove("playing");
        dom.progressFill.style.width = "0%";
        dom.timeCurrent.textContent = "0:00";
      }

      function togglePlayPause() {
        if (queue.length === 0) {
          setStatus("Add tracks to queue first", "error");
          return;
        }

        if (isPlaying) {
          Tone.Transport.pause();
          isPlaying = false;
          dom.albumArt.classList.remove("playing");
        } else {
          if (currentQueueIndex === -1) {
            playTrackAtIndex(0);
          } else {
            Tone.Transport.start();
            isPlaying = true;
            dom.albumArt.classList.add("playing");
          }
        }
        updatePlayButton();
      }

      function updatePlayButton() {
        const icon = dom.btnPlay.querySelector("svg");
        if (isPlaying) {
          icon.innerHTML =
            '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
        } else {
          icon.innerHTML = '<polygon points="5,3 19,12 5,21"/>';
        }
      }

      function onTrackEnd() {
        console.log("Track ended");

        // Clean up current players
        Object.values(players).forEach((p) => {
          try {
            p.unsync();
          } catch {}
        });

        // Next track logic
        if (currentQueueIndex < queue.length - 1) {
          playTrackAtIndex(currentQueueIndex + 1);
        } else if (repeatEnabled) {
          playTrackAtIndex(0);
        } else {
          stop();
          setStatus("Queue finished");
        }
      }

      function playNext() {
        if (currentQueueIndex < queue.length - 1) {
          playTrackAtIndex(currentQueueIndex + 1);
        } else if (repeatEnabled) {
          playTrackAtIndex(0);
        }
      }

      function playPrev() {
        if (currentQueueIndex > 0) {
          playTrackAtIndex(currentQueueIndex - 1);
        }
      }

      // ============================================
      // PROGRESS UPDATE
      // ============================================
      function updateProgress() {
        if (isPlaying && trackDuration > 0) {
          const currentTime = Tone.Transport.seconds;
          const percent = (currentTime / trackDuration) * 100;
          dom.progressFill.style.width = Math.min(percent, 100) + "%";
          dom.timeCurrent.textContent = formatTime(currentTime);
        }
        requestAnimationFrame(updateProgress);
      }

      // ============================================
      // PLAYBACK MODE
      // ============================================
      function setPlaybackMode(mode) {
        playbackMode = mode;
        document.querySelectorAll(".mode-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.mode === mode);
        });
      }

      // ============================================
      // URL PARAMETERS
      // ============================================
      function handleUrlParams() {
        const params = new URLSearchParams(window.location.search);
        const releaseId = params.get("release");

        if (releaseId) {
          // Hide admin link in shared mode
          document.querySelector('a[href="admin.html"]').style.display = "none";

          // Queue the specific release
          if (allReleases.find((r) => r.id === releaseId)) {
            queueRelease(releaseId);
          }
        } else {
          // Default: queue all tracks
          queueAllTracks();
        }
      }

      // ============================================
      // EVENT LISTENERS
      // ============================================
      document.querySelectorAll(".mode-btn").forEach((btn) => {
        btn.addEventListener("click", () => setPlaybackMode(btn.dataset.mode));
      });

      dom.btnPlay.addEventListener("click", togglePlayPause);
      dom.btnNext.addEventListener("click", playNext);
      dom.btnPrev.addEventListener("click", playPrev);
      dom.btnClearQueue.addEventListener("click", clearQueue);

      dom.btnShuffle.addEventListener("click", () => {
        shuffleEnabled = !shuffleEnabled;
        dom.btnShuffle.classList.toggle("active", shuffleEnabled);
        if (shuffleEnabled && queue.length > 1) {
          // Shuffle queue (keeping current track in place)
          const current = queue[currentQueueIndex];
          const others = queue.filter((_, i) => i !== currentQueueIndex);
          for (let i = others.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [others[i], others[j]] = [others[j], others[i]];
          }
          queue = [current, ...others];
          currentQueueIndex = 0;
          renderQueue();
        }
      });

      dom.btnRepeat.addEventListener("click", () => {
        repeatEnabled = !repeatEnabled;
        dom.btnRepeat.classList.toggle("active", repeatEnabled);
      });

      dom.btnInstrumental.addEventListener("click", () => {
        instrumentalMode = !instrumentalMode;
        dom.btnInstrumental.classList.toggle("active", instrumentalMode);
        dom.btnInstrumental.title = instrumentalMode
          ? "Instrumental ON (vocals muted)"
          : "Instrumental (mute vocals)";

        // Mute/unmute VOX stems in real-time
        for (const groupId in voxGainNodes) {
          const gainNode = voxGainNodes[groupId];
          if (gainNode) {
            gainNode.gain.rampTo(instrumentalMode ? 0 : 1, 0.3);
          }
        }

        const status = instrumentalMode
          ? "Instrumental mode ON"
          : "Vocals restored";
        setStatus(status, "success");
      });

      dom.btnCalm.addEventListener("click", () => {
        calmMode = !calmMode;
        dom.btnCalm.classList.toggle("active", calmMode);
        dom.btnCalm.title = calmMode
          ? "Calm Mode ON (rhythmic stems muted)"
          : "Calm Mode (mute rhythmic stems)";

        // Mute/unmute rhythmic stems in real-time
        for (const groupId in rhythmicGainNodes) {
          const gainNode = rhythmicGainNodes[groupId];
          if (gainNode) {
            gainNode.gain.rampTo(calmMode ? 0 : 1, 0.3);
          }
        }

        const status = calmMode ? "Calm mode ON" : "Full energy restored";
        setStatus(status, "success");
      });

      dom.progressBar.addEventListener("click", (e) => {
        if (trackDuration > 0) {
          const rect = dom.progressBar.getBoundingClientRect();
          const percent = (e.clientX - rect.left) / rect.width;
          Tone.Transport.seconds = percent * trackDuration;
        }
      });

      document
        .getElementById("btn-save-mix")
        .addEventListener("click", saveCurrentMix);

      // ============================================
      // SAVED MIXES (shared with player)
      // ============================================
      function loadSavedMixes() {
        try {
          const stored = localStorage.getItem(STORAGE_KEY);
          if (stored) {
            savedMixes = JSON.parse(stored);
          }
        } catch (e) {
          savedMixes = [];
        }
        renderSavedMixes();
      }

      function saveMixesToStorage() {
        try {
          localStorage.setItem(STORAGE_KEY, JSON.stringify(savedMixes));
        } catch (e) {
          console.error("Failed to save mixes:", e);
        }
      }

      function saveCurrentMix() {
        if (!currentTrackData || Object.keys(currentSelection).length === 0) {
          setStatus("No track playing to save", "error");
          return;
        }

        const name = prompt(
          "Name this mix:",
          `${currentTrackData.title} - Mix`
        );
        if (!name) return;

        const mix = {
          id: Date.now().toString(),
          name: name,
          createdAt: new Date().toISOString(),
          trackId: currentTrackData.id,
          trackTitle: currentTrackData.title,
          mode: null, // Playlist doesn't track mode the same way
          playbackMode: playbackMode,
          timeOverride: "auto",
          weatherOverride: "auto",
          selection: { ...currentSelection },
        };

        savedMixes.unshift(mix);
        saveMixesToStorage();
        renderSavedMixes();
        setStatus(`Saved "${name}" to favorites`, "success");
      }

      function deleteSavedMix(mixId, event) {
        event.stopPropagation();
        if (!confirm("Delete this saved mix?")) return;

        savedMixes = savedMixes.filter((m) => m.id !== mixId);
        saveMixesToStorage();
        renderSavedMixes();
        setStatus("Mix deleted", "success");
      }

      function renderSavedMixes() {
        const container = document.getElementById("saved-mixes-list");
        if (!container) return;

        if (savedMixes.length === 0) {
          container.innerHTML =
            '<div style="padding: 12px; color: var(--text-muted); font-size: 11px;">No saved mixes yet.<br>Click the bookmark icon while playing.</div>';
          return;
        }

        container.innerHTML = savedMixes
          .slice(0, 10)
          .map(
            (mix) => `
    <div class="sidebar-item" data-mix-id="${
      mix.id
    }" style="display: flex; align-items: center; gap: 8px;">
      <div style="flex: 1; min-width: 0;">
        <div class="sidebar-item-title">${escapeHtml(mix.name)}</div>
        <div class="sidebar-item-meta">${escapeHtml(mix.trackTitle)}</div>
      </div>
      <button onclick="deleteSavedMix('${
        mix.id
      }', event)" style="background: none; border: none; color: var(--text-muted); cursor: pointer; padding: 4px;" title="Delete">
        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
      </button>
    </div>
  `
          )
          .join("");

        // Add click handlers to load mix
        container.querySelectorAll(".sidebar-item").forEach((item) => {
          item.addEventListener("click", (e) => {
            if (!e.target.closest("button")) {
              loadSavedMix(item.dataset.mixId);
            }
          });
        });
      }

      async function loadSavedMix(mixId) {
        const mix = savedMixes.find((m) => m.id === mixId);
        if (!mix) return;

        // Find the track
        const track = allTracks.find((t) => t.id === mix.trackId);
        if (!track) {
          setStatus("Track not found for this mix", "error");
          return;
        }

        // Stop current playback
        await stop();

        // Set as current track
        currentTrackData = track;
        const release = allReleases.find((r) => r.id === track.release_id);
        currentTrackData.releaseName = release ? release.title : "";

        // Load track data
        await loadTrackData(track.id);

        // Restore the saved selection
        currentSelection = { ...mix.selection };

        // Restore playback mode
        playbackMode = mix.playbackMode || "fixed";
        document.querySelectorAll(".mode-btn").forEach((btn) => {
          btn.classList.toggle("active", btn.dataset.mode === playbackMode);
        });

        // Update UI
        updateNowPlaying();

        // Clear queue and add just this track
        queue = [
          {
            ...track,
            releaseName: currentTrackData.releaseName,
          },
        ];
        currentQueueIndex = 0;
        renderQueue();

        setStatus(`Loaded "${mix.name}"`, "success");

        // Auto-play
        await play();
      }

      // ============================================
      // INITIALIZATION
      // ============================================
      async function init() {
        loadSavedMixes();
        setupSettingsDropdown();
        await Promise.all([loadReleases(), loadAllTracks()]);
        renderReleasesList();
        handleUrlParams();
        updateProgress();
      }

      init();
    </script>
  </body>
</html>
